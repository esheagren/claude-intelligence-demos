<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network: Learning Visualized</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #0f1a2a 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0e0;
            display: flex;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        header h1 {
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 4px;
            background: linear-gradient(90deg, #64b5f6, #81c784);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        header .subtitle {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 5px;
            letter-spacing: 2px;
        }

        .canvas-container {
            flex: 1;
            position: relative;
        }

        #network-canvas {
            width: 100%;
            height: 100%;
        }

        .sidebar {
            width: 350px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
        }

        .panel h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #64b5f6;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .problem-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .problem-btn {
            padding: 12px;
            background: rgba(100, 181, 246, 0.1);
            border: 1px solid rgba(100, 181, 246, 0.3);
            color: #aaa;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
            text-align: center;
        }

        .problem-btn:hover {
            background: rgba(100, 181, 246, 0.2);
            color: #fff;
        }

        .problem-btn.active {
            background: rgba(100, 181, 246, 0.3);
            border-color: #64b5f6;
            color: #64b5f6;
        }

        .problem-btn .icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .btn {
            padding: 10px 15px;
            background: rgba(100, 181, 246, 0.1);
            border: 1px solid rgba(100, 181, 246, 0.2);
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(100, 181, 246, 0.2);
            color: #fff;
        }

        .btn.active {
            background: rgba(100, 181, 246, 0.3);
            border-color: #64b5f6;
            color: #64b5f6;
        }

        .btn.primary {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, rgba(100, 181, 246, 0.3), rgba(129, 199, 132, 0.3));
            border-color: #64b5f6;
            color: #fff;
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 5px;
        }

        .slider-group label span {
            color: #64b5f6;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(100, 181, 246, 0.2);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #64b5f6;
            border-radius: 50%;
            cursor: pointer;
        }

        .architecture-builder {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .layer-input {
            width: 40px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 181, 246, 0.3);
            color: #64b5f6;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
        }

        .layer-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 11px;
        }

        .stat-label { color: rgba(255, 255, 255, 0.5); }
        .stat-value { color: #fff; }
        .stat-value.good { color: #81c784; }
        .stat-value.bad { color: #e57373; }
        .stat-value.neutral { color: #64b5f6; }

        .loss-graph {
            height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            overflow: hidden;
            margin-top: 10px;
        }

        #loss-canvas {
            width: 100%;
            height: 100%;
        }

        .data-canvas-container {
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        #data-canvas {
            width: 100%;
            height: 100%;
        }

        .prediction-display {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .pred-item {
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            text-align: center;
        }

        .pred-label {
            font-size: 14px;
            margin-bottom: 3px;
        }

        .pred-value {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
        }

        .activation-display {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }

        .activation-btn {
            padding: 8px 5px;
            background: rgba(100, 181, 246, 0.1);
            border: 1px solid rgba(100, 181, 246, 0.2);
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 9px;
            text-align: center;
        }

        .activation-btn:hover {
            background: rgba(100, 181, 246, 0.2);
        }

        .activation-btn.active {
            background: rgba(100, 181, 246, 0.3);
            border-color: #64b5f6;
            color: #64b5f6;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(100, 181, 246, 0.3);
            border-radius: 6px;
            padding: 10px 15px;
            font-size: 11px;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .tooltip.visible {
            display: block;
        }

        .progress-bar {
            height: 4px;
            background: rgba(100, 181, 246, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #64b5f6, #81c784);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <header>
            <h1>NEURAL NETWORK</h1>
            <div class="subtitle">Interactive Learning Visualization</div>
        </header>
        <div class="canvas-container">
            <canvas id="network-canvas"></canvas>
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <div class="sidebar">
        <div class="panel">
            <h3>Learning Problem</h3>
            <div class="problem-selector">
                <div class="problem-btn active" data-problem="xor">
                    <div class="icon">XOR</div>
                    <div>XOR Gate</div>
                </div>
                <div class="problem-btn" data-problem="circle">
                    <div class="icon">O</div>
                    <div>Circle</div>
                </div>
                <div class="problem-btn" data-problem="spiral">
                    <div class="icon">@</div>
                    <div>Spiral</div>
                </div>
                <div class="problem-btn" data-problem="gaussian">
                    <div class="icon">#</div>
                    <div>Clusters</div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h3>Training Control</h3>
            <div class="btn-group">
                <button class="btn primary" id="train-btn">Train Network</button>
                <button class="btn" id="step-btn">Single Step</button>
                <button class="btn" id="reset-btn">Reset</button>
            </div>
            <div class="progress-bar" style="margin-top: 15px;">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="slider-group" style="margin-top: 15px;">
                <label>Learning Rate <span id="lr-val">0.1</span></label>
                <input type="range" id="learning-rate" min="1" max="100" value="10">
            </div>
            <div class="slider-group">
                <label>Training Speed <span id="speed-val">10</span> iter/frame</label>
                <input type="range" id="speed" min="1" max="50" value="10">
            </div>
        </div>

        <div class="panel">
            <h3>Network Architecture</h3>
            <div class="architecture-builder">
                <div>
                    <div class="layer-label">Input</div>
                    <input type="text" class="layer-input" id="input-size" value="2" readonly>
                </div>
                <div style="color: #64b5f6;">→</div>
                <div>
                    <div class="layer-label">Hidden 1</div>
                    <input type="number" class="layer-input" id="hidden1-size" value="8" min="1" max="32">
                </div>
                <div style="color: #64b5f6;">→</div>
                <div>
                    <div class="layer-label">Hidden 2</div>
                    <input type="number" class="layer-input" id="hidden2-size" value="6" min="1" max="32">
                </div>
                <div style="color: #64b5f6;">→</div>
                <div>
                    <div class="layer-label">Output</div>
                    <input type="text" class="layer-input" id="output-size" value="1" readonly>
                </div>
            </div>
            <button class="btn" id="rebuild-btn" style="margin-top: 10px; width: 100%;">Rebuild Network</button>
        </div>

        <div class="panel">
            <h3>Activation Function</h3>
            <div class="activation-display">
                <div class="activation-btn active" data-activation="relu">ReLU</div>
                <div class="activation-btn" data-activation="sigmoid">Sigmoid</div>
                <div class="activation-btn" data-activation="tanh">Tanh</div>
                <div class="activation-btn" data-activation="leaky">Leaky</div>
            </div>
        </div>

        <div class="panel">
            <h3>Training Statistics</h3>
            <div class="stat-row">
                <span class="stat-label">Epoch</span>
                <span class="stat-value neutral" id="epoch">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Loss</span>
                <span class="stat-value" id="loss">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Accuracy</span>
                <span class="stat-value" id="accuracy">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Parameters</span>
                <span class="stat-value neutral" id="params">0</span>
            </div>
            <div class="loss-graph">
                <canvas id="loss-canvas"></canvas>
            </div>
        </div>

        <div class="panel">
            <h3>Decision Boundary</h3>
            <div class="data-canvas-container">
                <canvas id="data-canvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // NEURAL NETWORK VISUALIZATION
        // ============================================

        const networkCanvas = document.getElementById('network-canvas');
        const networkCtx = networkCanvas.getContext('2d');
        const lossCanvas = document.getElementById('loss-canvas');
        const lossCtx = lossCanvas.getContext('2d');
        const dataCanvas = document.getElementById('data-canvas');
        const dataCtx = dataCanvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        // Network state
        let network = null;
        let trainData = [];
        let isTraining = false;
        let epoch = 0;
        let lossHistory = [];
        let learningRate = 0.1;
        let trainingSpeed = 10;
        let activationType = 'relu';
        let currentProblem = 'xor';

        // Architecture
        let architecture = [2, 8, 6, 1];

        // ============================================
        // ACTIVATION FUNCTIONS
        // ============================================

        const activations = {
            relu: {
                fn: x => Math.max(0, x),
                derivative: x => x > 0 ? 1 : 0
            },
            sigmoid: {
                fn: x => 1 / (1 + Math.exp(-x)),
                derivative: x => {
                    const s = 1 / (1 + Math.exp(-x));
                    return s * (1 - s);
                }
            },
            tanh: {
                fn: x => Math.tanh(x),
                derivative: x => 1 - Math.tanh(x) ** 2
            },
            leaky: {
                fn: x => x > 0 ? x : 0.01 * x,
                derivative: x => x > 0 ? 1 : 0.01
            }
        };

        // ============================================
        // NEURAL NETWORK CLASS
        // ============================================

        class NeuralNetwork {
            constructor(layers) {
                this.layers = layers;
                this.weights = [];
                this.biases = [];
                this.activations = [];
                this.zValues = [];

                // Initialize weights with Xavier initialization
                for (let i = 0; i < layers.length - 1; i++) {
                    const scale = Math.sqrt(2 / (layers[i] + layers[i + 1]));
                    this.weights.push(
                        Array(layers[i + 1]).fill(0).map(() =>
                            Array(layers[i]).fill(0).map(() => (Math.random() * 2 - 1) * scale)
                        )
                    );
                    this.biases.push(Array(layers[i + 1]).fill(0).map(() => 0));
                }
            }

            forward(input) {
                this.activations = [input];
                this.zValues = [];
                let current = input;

                for (let i = 0; i < this.weights.length; i++) {
                    const z = [];
                    const newActivations = [];

                    for (let j = 0; j < this.weights[i].length; j++) {
                        let sum = this.biases[i][j];
                        for (let k = 0; k < current.length; k++) {
                            sum += this.weights[i][j][k] * current[k];
                        }
                        z.push(sum);

                        // Use sigmoid for output layer, selected activation for hidden
                        const activation = i === this.weights.length - 1
                            ? activations.sigmoid.fn(sum)
                            : activations[activationType].fn(sum);
                        newActivations.push(activation);
                    }

                    this.zValues.push(z);
                    this.activations.push(newActivations);
                    current = newActivations;
                }

                return current;
            }

            backward(target) {
                const deltas = [];
                const numLayers = this.weights.length;

                // Output layer error
                const outputIndex = numLayers;
                const outputDelta = [];
                for (let i = 0; i < this.activations[outputIndex].length; i++) {
                    const output = this.activations[outputIndex][i];
                    const error = output - target[i];
                    // Sigmoid derivative for output
                    outputDelta.push(error * output * (1 - output));
                }
                deltas[numLayers - 1] = outputDelta;

                // Hidden layers
                for (let l = numLayers - 2; l >= 0; l--) {
                    const layerDelta = [];
                    for (let j = 0; j < this.weights[l].length; j++) {
                        let error = 0;
                        for (let k = 0; k < this.weights[l + 1].length; k++) {
                            error += deltas[l + 1][k] * this.weights[l + 1][k][j];
                        }
                        const derivative = activations[activationType].derivative(this.zValues[l][j]);
                        layerDelta.push(error * derivative);
                    }
                    deltas[l] = layerDelta;
                }

                // Update weights and biases
                for (let l = 0; l < numLayers; l++) {
                    for (let j = 0; j < this.weights[l].length; j++) {
                        for (let k = 0; k < this.weights[l][j].length; k++) {
                            this.weights[l][j][k] -= learningRate * deltas[l][j] * this.activations[l][k];
                        }
                        this.biases[l][j] -= learningRate * deltas[l][j];
                    }
                }
            }

            train(inputs, targets) {
                let totalLoss = 0;

                for (let i = 0; i < inputs.length; i++) {
                    const output = this.forward(inputs[i]);
                    this.backward(targets[i]);

                    // Calculate loss (MSE)
                    for (let j = 0; j < output.length; j++) {
                        totalLoss += (output[j] - targets[i][j]) ** 2;
                    }
                }

                return totalLoss / inputs.length;
            }

            countParameters() {
                let count = 0;
                for (let i = 0; i < this.weights.length; i++) {
                    count += this.weights[i].length * this.weights[i][0].length;
                    count += this.biases[i].length;
                }
                return count;
            }
        }

        // ============================================
        // DATA GENERATION
        // ============================================

        function generateData(problem, count = 200) {
            const data = { inputs: [], targets: [] };

            switch (problem) {
                case 'xor':
                    for (let i = 0; i < count; i++) {
                        const x = Math.random();
                        const y = Math.random();
                        const target = (x > 0.5) !== (y > 0.5) ? 1 : 0;
                        data.inputs.push([x, y]);
                        data.targets.push([target]);
                    }
                    break;

                case 'circle':
                    for (let i = 0; i < count; i++) {
                        const x = Math.random();
                        const y = Math.random();
                        const dist = Math.sqrt((x - 0.5) ** 2 + (y - 0.5) ** 2);
                        const target = dist < 0.3 ? 1 : 0;
                        data.inputs.push([x, y]);
                        data.targets.push([target]);
                    }
                    break;

                case 'spiral':
                    for (let i = 0; i < count / 2; i++) {
                        const angle = i / (count / 2) * 3 * Math.PI;
                        const r = 0.1 + 0.35 * i / (count / 2);

                        // Class 0
                        const x0 = 0.5 + r * Math.cos(angle) + (Math.random() - 0.5) * 0.1;
                        const y0 = 0.5 + r * Math.sin(angle) + (Math.random() - 0.5) * 0.1;
                        data.inputs.push([x0, y0]);
                        data.targets.push([0]);

                        // Class 1
                        const x1 = 0.5 + r * Math.cos(angle + Math.PI) + (Math.random() - 0.5) * 0.1;
                        const y1 = 0.5 + r * Math.sin(angle + Math.PI) + (Math.random() - 0.5) * 0.1;
                        data.inputs.push([x1, y1]);
                        data.targets.push([1]);
                    }
                    break;

                case 'gaussian':
                    for (let i = 0; i < count / 2; i++) {
                        // Cluster 1
                        const x0 = 0.3 + (Math.random() - 0.5) * 0.3;
                        const y0 = 0.3 + (Math.random() - 0.5) * 0.3;
                        data.inputs.push([x0, y0]);
                        data.targets.push([0]);

                        // Cluster 2
                        const x1 = 0.7 + (Math.random() - 0.5) * 0.3;
                        const y1 = 0.7 + (Math.random() - 0.5) * 0.3;
                        data.inputs.push([x1, y1]);
                        data.targets.push([1]);
                    }
                    break;
            }

            return data;
        }

        // ============================================
        // VISUALIZATION
        // ============================================

        function resize() {
            networkCanvas.width = networkCanvas.parentElement.clientWidth;
            networkCanvas.height = networkCanvas.parentElement.clientHeight;
            lossCanvas.width = lossCanvas.parentElement.clientWidth;
            lossCanvas.height = lossCanvas.parentElement.clientHeight;
            dataCanvas.width = dataCanvas.parentElement.clientWidth;
            dataCanvas.height = dataCanvas.parentElement.clientHeight;
        }

        function drawNetwork() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;

            networkCtx.fillStyle = 'rgba(10, 10, 26, 1)';
            networkCtx.fillRect(0, 0, width, height);

            if (!network) return;

            const layers = network.layers;
            const layerSpacing = width / (layers.length + 1);
            const maxNodes = Math.max(...layers);

            // Calculate node positions
            const nodePositions = [];
            for (let l = 0; l < layers.length; l++) {
                nodePositions[l] = [];
                const nodeSpacing = height / (layers[l] + 1);
                const x = layerSpacing * (l + 1);

                for (let n = 0; n < layers[l]; n++) {
                    const y = nodeSpacing * (n + 1);
                    nodePositions[l][n] = { x, y };
                }
            }

            // Draw connections
            for (let l = 0; l < network.weights.length; l++) {
                for (let j = 0; j < network.weights[l].length; j++) {
                    for (let k = 0; k < network.weights[l][j].length; k++) {
                        const weight = network.weights[l][j][k];
                        const absWeight = Math.abs(weight);
                        const intensity = Math.min(1, absWeight);

                        const start = nodePositions[l][k];
                        const end = nodePositions[l + 1][j];

                        // Color based on weight sign
                        if (weight > 0) {
                            networkCtx.strokeStyle = `rgba(100, 181, 246, ${intensity * 0.6})`;
                        } else {
                            networkCtx.strokeStyle = `rgba(229, 115, 115, ${intensity * 0.6})`;
                        }

                        networkCtx.lineWidth = absWeight * 2;
                        networkCtx.beginPath();
                        networkCtx.moveTo(start.x, start.y);
                        networkCtx.lineTo(end.x, end.y);
                        networkCtx.stroke();
                    }
                }
            }

            // Draw nodes
            for (let l = 0; l < layers.length; l++) {
                for (let n = 0; n < layers[l]; n++) {
                    const pos = nodePositions[l][n];
                    let activation = 0;

                    if (network.activations && network.activations[l]) {
                        activation = network.activations[l][n] || 0;
                    }

                    // Glow
                    const gradient = networkCtx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 25);
                    gradient.addColorStop(0, `rgba(100, 181, 246, ${activation * 0.3})`);
                    gradient.addColorStop(1, 'rgba(100, 181, 246, 0)');
                    networkCtx.fillStyle = gradient;
                    networkCtx.beginPath();
                    networkCtx.arc(pos.x, pos.y, 25, 0, Math.PI * 2);
                    networkCtx.fill();

                    // Node
                    const brightness = 30 + activation * 50;
                    networkCtx.fillStyle = `hsl(210, 60%, ${brightness}%)`;
                    networkCtx.beginPath();
                    networkCtx.arc(pos.x, pos.y, 12, 0, Math.PI * 2);
                    networkCtx.fill();

                    // Border
                    networkCtx.strokeStyle = `rgba(100, 181, 246, ${0.3 + activation * 0.5})`;
                    networkCtx.lineWidth = 2;
                    networkCtx.stroke();

                    // Activation value
                    if (activation !== 0) {
                        networkCtx.fillStyle = '#fff';
                        networkCtx.font = '9px sans-serif';
                        networkCtx.textAlign = 'center';
                        networkCtx.fillText(activation.toFixed(2), pos.x, pos.y + 3);
                    }
                }
            }

            // Draw layer labels
            networkCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            networkCtx.font = '11px sans-serif';
            networkCtx.textAlign = 'center';

            const labels = ['Input', ...Array(layers.length - 2).fill(0).map((_, i) => `Hidden ${i + 1}`), 'Output'];
            for (let l = 0; l < layers.length; l++) {
                const x = layerSpacing * (l + 1);
                networkCtx.fillText(labels[l], x, 30);
            }
        }

        function drawLossGraph() {
            const width = lossCanvas.width;
            const height = lossCanvas.height;

            lossCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            lossCtx.fillRect(0, 0, width, height);

            if (lossHistory.length < 2) return;

            const maxLoss = Math.max(...lossHistory, 0.5);
            const step = width / (lossHistory.length - 1);

            lossCtx.beginPath();
            lossCtx.moveTo(0, height - (lossHistory[0] / maxLoss) * height * 0.9);

            for (let i = 1; i < lossHistory.length; i++) {
                const x = i * step;
                const y = height - (lossHistory[i] / maxLoss) * height * 0.9;
                lossCtx.lineTo(x, y);
            }

            lossCtx.strokeStyle = '#81c784';
            lossCtx.lineWidth = 2;
            lossCtx.stroke();
        }

        function drawDecisionBoundary() {
            const width = dataCanvas.width;
            const height = dataCanvas.height;

            if (!network) {
                dataCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                dataCtx.fillRect(0, 0, width, height);
                return;
            }

            // Draw decision boundary
            const imageData = dataCtx.createImageData(width, height);
            const data = imageData.data;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x = px / width;
                    const y = py / height;

                    const output = network.forward([x, y])[0];
                    const idx = (py * width + px) * 4;

                    // Blue for class 0, orange for class 1
                    if (output < 0.5) {
                        const intensity = (0.5 - output) * 2;
                        data[idx] = 100 * intensity;
                        data[idx + 1] = 181 * intensity;
                        data[idx + 2] = 246 * intensity;
                    } else {
                        const intensity = (output - 0.5) * 2;
                        data[idx] = 255 * intensity;
                        data[idx + 1] = 167 * intensity;
                        data[idx + 2] = 38 * intensity;
                    }
                    data[idx + 3] = 100;
                }
            }

            dataCtx.putImageData(imageData, 0, 0);

            // Draw data points
            for (let i = 0; i < trainData.inputs.length; i++) {
                const x = trainData.inputs[i][0] * width;
                const y = trainData.inputs[i][1] * height;
                const target = trainData.targets[i][0];

                dataCtx.beginPath();
                dataCtx.arc(x, y, 4, 0, Math.PI * 2);
                dataCtx.fillStyle = target > 0.5 ? '#ffa726' : '#64b5f6';
                dataCtx.fill();
                dataCtx.strokeStyle = '#fff';
                dataCtx.lineWidth = 1;
                dataCtx.stroke();
            }
        }

        function updateStats() {
            document.getElementById('epoch').textContent = epoch;
            document.getElementById('params').textContent = network ? network.countParameters() : 0;

            if (lossHistory.length > 0) {
                const currentLoss = lossHistory[lossHistory.length - 1];
                const lossEl = document.getElementById('loss');
                lossEl.textContent = currentLoss.toFixed(6);
                lossEl.className = 'stat-value ' + (currentLoss < 0.1 ? 'good' : currentLoss > 0.3 ? 'bad' : '');

                // Calculate accuracy
                let correct = 0;
                for (let i = 0; i < trainData.inputs.length; i++) {
                    const output = network.forward(trainData.inputs[i])[0];
                    const predicted = output > 0.5 ? 1 : 0;
                    if (predicted === trainData.targets[i][0]) correct++;
                }
                const accuracy = (correct / trainData.inputs.length * 100).toFixed(1);
                const accEl = document.getElementById('accuracy');
                accEl.textContent = accuracy + '%';
                accEl.className = 'stat-value ' + (accuracy > 90 ? 'good' : accuracy < 70 ? 'bad' : '');
            }

            // Progress bar
            const progress = Math.min(100, epoch / 10);
            document.getElementById('progress-fill').style.width = progress + '%';
        }

        // ============================================
        // TRAINING LOOP
        // ============================================

        function trainStep() {
            if (!isTraining || !network) return;

            for (let i = 0; i < trainingSpeed; i++) {
                const loss = network.train(trainData.inputs, trainData.targets);

                if (epoch % 10 === 0) {
                    lossHistory.push(loss);
                    if (lossHistory.length > 200) lossHistory.shift();
                }

                epoch++;
            }

            // Run a sample forward pass for visualization
            const sampleIdx = Math.floor(Math.random() * trainData.inputs.length);
            network.forward(trainData.inputs[sampleIdx]);

            updateStats();
            drawNetwork();
            drawLossGraph();
            drawDecisionBoundary();

            requestAnimationFrame(trainStep);
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        function resetNetwork() {
            network = new NeuralNetwork(architecture);
            trainData = generateData(currentProblem);
            epoch = 0;
            lossHistory = [];
            isTraining = false;
            document.getElementById('train-btn').textContent = 'Train Network';

            updateStats();
            drawNetwork();
            drawDecisionBoundary();
        }

        function init() {
            resize();
            window.addEventListener('resize', resize);

            // Problem selector
            document.querySelectorAll('.problem-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.problem-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentProblem = btn.dataset.problem;
                    resetNetwork();
                });
            });

            // Training controls
            document.getElementById('train-btn').addEventListener('click', () => {
                isTraining = !isTraining;
                document.getElementById('train-btn').textContent = isTraining ? 'Pause Training' : 'Train Network';
                if (isTraining) trainStep();
            });

            document.getElementById('step-btn').addEventListener('click', () => {
                if (network) {
                    const loss = network.train(trainData.inputs, trainData.targets);
                    lossHistory.push(loss);
                    epoch++;
                    network.forward(trainData.inputs[0]);
                    updateStats();
                    drawNetwork();
                    drawLossGraph();
                    drawDecisionBoundary();
                }
            });

            document.getElementById('reset-btn').addEventListener('click', resetNetwork);

            document.getElementById('rebuild-btn').addEventListener('click', () => {
                const h1 = parseInt(document.getElementById('hidden1-size').value) || 4;
                const h2 = parseInt(document.getElementById('hidden2-size').value) || 4;
                architecture = [2, h1, h2, 1];
                resetNetwork();
            });

            // Sliders
            document.getElementById('learning-rate').addEventListener('input', (e) => {
                learningRate = e.target.value / 100;
                document.getElementById('lr-val').textContent = learningRate.toFixed(2);
            });

            document.getElementById('speed').addEventListener('input', (e) => {
                trainingSpeed = parseInt(e.target.value);
                document.getElementById('speed-val').textContent = trainingSpeed;
            });

            // Activation selector
            document.querySelectorAll('.activation-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.activation-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    activationType = btn.dataset.activation;
                });
            });

            // Initialize
            resetNetwork();
        }

        init();
    </script>
</body>
</html>
