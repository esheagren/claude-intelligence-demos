<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            font-size: 42px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00d9ff, #0099cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .control-group label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        select, button {
            padding: 10px 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        select:hover, button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        button.primary {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.3), rgba(0, 153, 204, 0.3));
            border-color: #00d9ff;
        }

        button.primary:hover {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.5), rgba(0, 153, 204, 0.5));
        }

        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .board-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
        }

        .stats-bar {
            display: flex;
            gap: 30px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #00d9ff;
            font-family: monospace;
        }

        .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.5);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 2px;
            background: rgba(255, 255, 255, 0.3);
            padding: 2px;
            border-radius: 8px;
        }

        .cell {
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(30, 30, 50, 0.9);
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
        }

        .cell:hover {
            background: rgba(0, 217, 255, 0.2);
        }

        .cell.selected {
            background: rgba(0, 217, 255, 0.4);
            box-shadow: inset 0 0 10px rgba(0, 217, 255, 0.5);
        }

        .cell.highlighted {
            background: rgba(0, 217, 255, 0.15);
        }

        .cell.same-number {
            background: rgba(0, 217, 255, 0.25);
        }

        .cell.given {
            color: #fff;
        }

        .cell.user {
            color: #00d9ff;
        }

        .cell.error {
            color: #ff4757;
            background: rgba(255, 71, 87, 0.2);
        }

        .cell.correct-reveal {
            animation: correctPulse 0.5s ease;
        }

        @keyframes correctPulse {
            0%, 100% { background: rgba(30, 30, 50, 0.9); }
            50% { background: rgba(0, 255, 136, 0.3); }
        }

        /* 3x3 box borders */
        .cell:nth-child(3n) {
            border-right: 2px solid rgba(255, 255, 255, 0.4);
        }

        .cell:nth-child(9n) {
            border-right: none;
        }

        .cell:nth-child(n+19):nth-child(-n+27),
        .cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid rgba(255, 255, 255, 0.4);
        }

        /* Pencil marks */
        .pencil-marks {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .pencil-mark {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .number-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .num-btn {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 24px;
            color: #fff;
            cursor: pointer;
            transition: all 0.15s;
        }

        .num-btn:hover {
            background: rgba(0, 217, 255, 0.2);
            border-color: #00d9ff;
        }

        .num-btn.exhausted {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .tool-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .tool-btn {
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .tool-btn.active {
            background: rgba(0, 217, 255, 0.3);
            border-color: #00d9ff;
        }

        .tool-icon {
            font-size: 18px;
        }

        .hints-remaining {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
        }

        .message {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 16px;
        }

        .message.success {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid rgba(0, 255, 136, 0.5);
            color: #00ff88;
        }

        .message.error {
            background: rgba(255, 71, 87, 0.2);
            border: 1px solid rgba(255, 71, 87, 0.5);
            color: #ff4757;
        }

        .keyboard-hint {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
            margin-top: 15px;
        }

        @media (max-width: 600px) {
            .cell {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }

            .num-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }

            .game-container {
                flex-direction: column;
            }

            .pencil-mark {
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <h1>Sudoku</h1>
    <p class="subtitle">Fill the grid so each row, column, and 3x3 box contains 1-9</p>

    <div class="controls">
        <div class="control-group">
            <label>Difficulty:</label>
            <select id="difficulty">
                <option value="easy">Easy</option>
                <option value="medium" selected>Medium</option>
                <option value="hard">Hard</option>
                <option value="expert">Expert</option>
            </select>
        </div>
        <button class="primary" id="newGameBtn">New Game</button>
    </div>

    <div class="game-container">
        <div class="board-container">
            <div class="stats-bar">
                <div class="stat">
                    <div class="stat-value" id="timer">00:00</div>
                    <div class="stat-label">Time</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="mistakes">0/3</div>
                    <div class="stat-label">Mistakes</div>
                </div>
            </div>

            <div class="board" id="board"></div>

            <div class="number-pad" id="numberPad"></div>

            <div id="messageArea"></div>
        </div>

        <div class="side-panel">
            <div class="tool-buttons">
                <button class="tool-btn" id="pencilBtn">
                    <span class="tool-icon">‚úèÔ∏è</span>
                    <span>Pencil Mode</span>
                </button>
                <button class="tool-btn" id="eraseBtn">
                    <span class="tool-icon">üßπ</span>
                    <span>Erase</span>
                </button>
                <button class="tool-btn" id="hintBtn">
                    <span class="tool-icon">üí°</span>
                    <span>Hint</span>
                    <span class="hints-remaining" id="hintsRemaining">(3 left)</span>
                </button>
                <button class="tool-btn" id="undoBtn">
                    <span class="tool-icon">‚Ü©Ô∏è</span>
                    <span>Undo</span>
                </button>
                <button class="tool-btn" id="checkBtn">
                    <span class="tool-icon">‚úì</span>
                    <span>Check</span>
                </button>
            </div>

            <p class="keyboard-hint">
                Use 1-9 keys to enter numbers<br>
                Delete/Backspace to erase<br>
                Arrow keys to navigate
            </p>
        </div>
    </div>

    <script>
        // Game state
        let board = [];
        let solution = [];
        let given = [];
        let pencilMarks = [];
        let selectedCell = null;
        let pencilMode = false;
        let mistakes = 0;
        let maxMistakes = 3;
        let hints = 3;
        let timerInterval = null;
        let seconds = 0;
        let history = [];
        let gameOver = false;

        // Difficulty settings (number of cells to remove)
        const difficulties = {
            easy: 35,
            medium: 45,
            hard: 52,
            expert: 58
        };

        function init() {
            createBoard();
            createNumberPad();
            setupEventListeners();
            newGame();
        }

        function createBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;

                const pencilContainer = document.createElement('div');
                pencilContainer.className = 'pencil-marks';
                for (let n = 1; n <= 9; n++) {
                    const mark = document.createElement('div');
                    mark.className = 'pencil-mark';
                    mark.dataset.num = n;
                    pencilContainer.appendChild(mark);
                }
                cell.appendChild(pencilContainer);

                cell.addEventListener('click', () => selectCell(i));
                boardEl.appendChild(cell);
            }
        }

        function createNumberPad() {
            const padEl = document.getElementById('numberPad');
            padEl.innerHTML = '';

            for (let n = 1; n <= 9; n++) {
                const btn = document.createElement('div');
                btn.className = 'num-btn';
                btn.textContent = n;
                btn.addEventListener('click', () => enterNumber(n));
                padEl.appendChild(btn);
            }
        }

        function setupEventListeners() {
            document.getElementById('newGameBtn').addEventListener('click', newGame);
            document.getElementById('pencilBtn').addEventListener('click', togglePencilMode);
            document.getElementById('eraseBtn').addEventListener('click', eraseCell);
            document.getElementById('hintBtn').addEventListener('click', giveHint);
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('checkBtn').addEventListener('click', checkBoard);

            document.addEventListener('keydown', handleKeyPress);
        }

        function handleKeyPress(e) {
            if (gameOver) return;

            if (e.key >= '1' && e.key <= '9') {
                enterNumber(parseInt(e.key));
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                eraseCell();
            } else if (e.key === 'ArrowUp' && selectedCell !== null) {
                e.preventDefault();
                selectCell(Math.max(0, selectedCell - 9));
            } else if (e.key === 'ArrowDown' && selectedCell !== null) {
                e.preventDefault();
                selectCell(Math.min(80, selectedCell + 9));
            } else if (e.key === 'ArrowLeft' && selectedCell !== null) {
                e.preventDefault();
                selectCell(Math.max(0, selectedCell - 1));
            } else if (e.key === 'ArrowRight' && selectedCell !== null) {
                e.preventDefault();
                selectCell(Math.min(80, selectedCell + 1));
            } else if (e.key === 'p' || e.key === 'P') {
                togglePencilMode();
            }
        }

        function newGame() {
            const difficulty = document.getElementById('difficulty').value;
            const cellsToRemove = difficulties[difficulty];

            // Generate solved board
            solution = generateSolvedBoard();
            board = solution.map(row => [...row]);

            // Remove cells based on difficulty
            given = Array(9).fill(null).map(() => Array(9).fill(true));
            pencilMarks = Array(81).fill(null).map(() => new Set());

            let removed = 0;
            const positions = [];
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    positions.push([r, c]);
                }
            }
            shuffleArray(positions);

            for (const [r, c] of positions) {
                if (removed >= cellsToRemove) break;
                const temp = board[r][c];
                board[r][c] = 0;
                given[r][c] = false;

                // Check if still has unique solution (simplified - just remove)
                removed++;
            }

            // Reset game state
            selectedCell = null;
            pencilMode = false;
            mistakes = 0;
            hints = 3;
            history = [];
            gameOver = false;
            seconds = 0;

            // Reset UI
            document.getElementById('pencilBtn').classList.remove('active');
            document.getElementById('mistakes').textContent = `${mistakes}/${maxMistakes}`;
            document.getElementById('hintsRemaining').textContent = `(${hints} left)`;
            document.getElementById('messageArea').innerHTML = '';

            // Start timer
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);

            renderBoard();
            updateNumberCounts();
        }

        function generateSolvedBoard() {
            const board = Array(9).fill(null).map(() => Array(9).fill(0));

            // Fill diagonal 3x3 boxes first (they don't affect each other)
            for (let box = 0; box < 9; box += 3) {
                fillBox(board, box, box);
            }

            // Solve the rest
            solveSudoku(board);

            return board;
        }

        function fillBox(board, startRow, startCol) {
            const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            shuffleArray(nums);
            let idx = 0;

            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    board[startRow + r][startCol + c] = nums[idx++];
                }
            }
        }

        function solveSudoku(board) {
            const empty = findEmpty(board);
            if (!empty) return true;

            const [row, col] = empty;
            const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            shuffleArray(nums);

            for (const num of nums) {
                if (isValid(board, row, col, num)) {
                    board[row][col] = num;
                    if (solveSudoku(board)) return true;
                    board[row][col] = 0;
                }
            }

            return false;
        }

        function findEmpty(board) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) return [r, c];
                }
            }
            return null;
        }

        function isValid(board, row, col, num) {
            // Check row
            for (let c = 0; c < 9; c++) {
                if (board[row][c] === num) return false;
            }

            // Check column
            for (let r = 0; r < 9; r++) {
                if (board[r][col] === num) return false;
            }

            // Check 3x3 box
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            for (let r = boxRow; r < boxRow + 3; r++) {
                for (let c = boxCol; c < boxCol + 3; c++) {
                    if (board[r][c] === num) return false;
                }
            }

            return true;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function selectCell(index) {
            if (gameOver) return;

            const cells = document.querySelectorAll('.cell');

            // Remove previous selection highlighting
            cells.forEach(cell => {
                cell.classList.remove('selected', 'highlighted', 'same-number');
            });

            selectedCell = index;
            const row = Math.floor(index / 9);
            const col = index % 9;
            const selectedNum = board[row][col];

            // Highlight row, column, and box
            for (let i = 0; i < 81; i++) {
                const r = Math.floor(i / 9);
                const c = i % 9;
                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;

                if (r === row || c === col ||
                    (r >= boxRow && r < boxRow + 3 && c >= boxCol && c < boxCol + 3)) {
                    cells[i].classList.add('highlighted');
                }

                // Highlight same numbers
                if (selectedNum !== 0 && board[r][c] === selectedNum) {
                    cells[i].classList.add('same-number');
                }
            }

            cells[index].classList.add('selected');
        }

        function enterNumber(num) {
            if (selectedCell === null || gameOver) return;

            const row = Math.floor(selectedCell / 9);
            const col = selectedCell % 9;

            if (given[row][col]) return; // Can't modify given cells

            if (pencilMode) {
                // Toggle pencil mark
                const marks = pencilMarks[selectedCell];
                if (marks.has(num)) {
                    marks.delete(num);
                } else {
                    marks.add(num);
                }
                // Save history
                history.push({
                    type: 'pencil',
                    index: selectedCell,
                    marks: new Set(marks)
                });
            } else {
                // Save history
                history.push({
                    type: 'number',
                    index: selectedCell,
                    oldValue: board[row][col],
                    oldMarks: new Set(pencilMarks[selectedCell])
                });

                // Clear pencil marks when entering number
                pencilMarks[selectedCell].clear();

                // Check if correct
                if (num !== solution[row][col]) {
                    mistakes++;
                    document.getElementById('mistakes').textContent = `${mistakes}/${maxMistakes}`;

                    if (mistakes >= maxMistakes) {
                        endGame(false);
                        return;
                    }
                }

                board[row][col] = num;

                // Remove this number from pencil marks in same row/col/box
                removePencilMarksFor(row, col, num);
            }

            renderBoard();
            updateNumberCounts();
            checkWin();
        }

        function removePencilMarksFor(row, col, num) {
            // Remove from row
            for (let c = 0; c < 9; c++) {
                pencilMarks[row * 9 + c].delete(num);
            }
            // Remove from column
            for (let r = 0; r < 9; r++) {
                pencilMarks[r * 9 + col].delete(num);
            }
            // Remove from box
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            for (let r = boxRow; r < boxRow + 3; r++) {
                for (let c = boxCol; c < boxCol + 3; c++) {
                    pencilMarks[r * 9 + c].delete(num);
                }
            }
        }

        function eraseCell() {
            if (selectedCell === null || gameOver) return;

            const row = Math.floor(selectedCell / 9);
            const col = selectedCell % 9;

            if (given[row][col]) return;

            // Save history
            history.push({
                type: 'erase',
                index: selectedCell,
                oldValue: board[row][col],
                oldMarks: new Set(pencilMarks[selectedCell])
            });

            board[row][col] = 0;
            pencilMarks[selectedCell].clear();

            renderBoard();
            updateNumberCounts();
        }

        function togglePencilMode() {
            pencilMode = !pencilMode;
            document.getElementById('pencilBtn').classList.toggle('active', pencilMode);
        }

        function giveHint() {
            if (hints <= 0 || gameOver) return;

            // Find an empty cell
            const emptyCells = [];
            for (let i = 0; i < 81; i++) {
                const row = Math.floor(i / 9);
                const col = i % 9;
                if (board[row][col] === 0) {
                    emptyCells.push(i);
                }
            }

            if (emptyCells.length === 0) return;

            // Pick random empty cell
            const index = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            const row = Math.floor(index / 9);
            const col = index % 9;

            // Save history
            history.push({
                type: 'hint',
                index: index,
                oldValue: board[row][col],
                oldMarks: new Set(pencilMarks[index])
            });

            // Fill with correct value
            board[row][col] = solution[row][col];
            pencilMarks[index].clear();
            given[row][col] = true; // Mark as given so it can't be erased

            hints--;
            document.getElementById('hintsRemaining').textContent = `(${hints} left)`;

            // Animate the hint
            const cells = document.querySelectorAll('.cell');
            cells[index].classList.add('correct-reveal');
            setTimeout(() => cells[index].classList.remove('correct-reveal'), 500);

            renderBoard();
            updateNumberCounts();
            checkWin();
        }

        function undo() {
            if (history.length === 0 || gameOver) return;

            const action = history.pop();
            const row = Math.floor(action.index / 9);
            const col = action.index % 9;

            if (action.type === 'number' || action.type === 'erase') {
                board[row][col] = action.oldValue;
                pencilMarks[action.index] = new Set(action.oldMarks);
            } else if (action.type === 'pencil') {
                pencilMarks[action.index] = new Set(action.oldMarks);
            } else if (action.type === 'hint') {
                board[row][col] = action.oldValue;
                pencilMarks[action.index] = new Set(action.oldMarks);
                given[row][col] = false;
                hints++;
                document.getElementById('hintsRemaining').textContent = `(${hints} left)`;
            }

            renderBoard();
            updateNumberCounts();
        }

        function checkBoard() {
            if (gameOver) return;

            const cells = document.querySelectorAll('.cell');
            let hasErrors = false;

            for (let i = 0; i < 81; i++) {
                const row = Math.floor(i / 9);
                const col = i % 9;

                if (board[row][col] !== 0 && board[row][col] !== solution[row][col]) {
                    cells[i].classList.add('error');
                    hasErrors = true;
                }
            }

            if (hasErrors) {
                showMessage('Some numbers are incorrect!', 'error');
            } else {
                showMessage('Looking good so far!', 'success');
            }

            setTimeout(() => {
                cells.forEach(cell => cell.classList.remove('error'));
            }, 2000);
        }

        function checkWin() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] !== solution[r][c]) return;
                }
            }

            endGame(true);
        }

        function endGame(won) {
            gameOver = true;
            if (timerInterval) clearInterval(timerInterval);

            if (won) {
                showMessage(`Congratulations! Solved in ${formatTime(seconds)}`, 'success');
            } else {
                showMessage('Game Over! Too many mistakes.', 'error');
                // Reveal solution
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        board[r][c] = solution[r][c];
                    }
                }
                renderBoard();
            }
        }

        function showMessage(text, type) {
            const messageArea = document.getElementById('messageArea');
            messageArea.innerHTML = `<div class="message ${type}">${text}</div>`;
        }

        function renderBoard() {
            const cells = document.querySelectorAll('.cell');

            for (let i = 0; i < 81; i++) {
                const row = Math.floor(i / 9);
                const col = i % 9;
                const cell = cells[i];
                const value = board[row][col];
                const isGiven = given[row][col];

                // Clear text content (keep pencil marks container)
                const pencilContainer = cell.querySelector('.pencil-marks');

                // Remove all child text nodes
                Array.from(cell.childNodes).forEach(node => {
                    if (node.nodeType === 3) node.remove();
                });

                // Set classes
                cell.className = 'cell';
                if (i === selectedCell) cell.classList.add('selected');

                if (value !== 0) {
                    // Show number
                    cell.insertBefore(document.createTextNode(value), pencilContainer);
                    cell.classList.add(isGiven ? 'given' : 'user');

                    // Check for errors (only for user-entered numbers)
                    if (!isGiven && value !== solution[row][col]) {
                        cell.classList.add('error');
                    }

                    // Hide pencil marks
                    pencilContainer.style.display = 'none';
                } else {
                    // Show pencil marks
                    pencilContainer.style.display = 'grid';
                    const marks = pencilMarks[i];
                    const markElements = pencilContainer.querySelectorAll('.pencil-mark');
                    markElements.forEach((el, idx) => {
                        el.textContent = marks.has(idx + 1) ? (idx + 1) : '';
                    });
                }
            }

            // Reapply highlighting if a cell is selected
            if (selectedCell !== null) {
                selectCell(selectedCell);
            }
        }

        function updateNumberCounts() {
            const counts = Array(10).fill(0);
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    counts[board[r][c]]++;
                }
            }

            const numBtns = document.querySelectorAll('.num-btn');
            numBtns.forEach((btn, idx) => {
                const num = idx + 1;
                btn.classList.toggle('exhausted', counts[num] >= 9);
            });
        }

        function updateTimer() {
            seconds++;
            document.getElementById('timer').textContent = formatTime(seconds);
        }

        function formatTime(secs) {
            const mins = Math.floor(secs / 60);
            const s = secs % 60;
            return `${mins.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // Initialize
        init();
    </script>
</body>
</html>
