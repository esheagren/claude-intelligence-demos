<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        h1 {
            font-size: 1.3em;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 0.75em;
            color: #666;
            margin-bottom: 20px;
        }

        .section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section h3 {
            font-size: 0.8em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
            flex: 1;
        }

        .btn:hover {
            background: rgba(255, 107, 107, 0.3);
            border-color: #ff6b6b;
        }

        .btn.active {
            background: rgba(255, 107, 107, 0.4);
            border-color: #ff6b6b;
        }

        .viz-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .viz-btn {
            padding: 10px 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75em;
            text-align: center;
            transition: all 0.2s;
        }

        .viz-btn:hover {
            background: rgba(254, 202, 87, 0.2);
            border-color: #feca57;
        }

        .viz-btn.active {
            background: rgba(254, 202, 87, 0.3);
            border-color: #feca57;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            font-size: 0.75em;
            color: #aaa;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff6b6b;
            cursor: pointer;
        }

        .value-display {
            font-size: 0.7em;
            color: #ff6b6b;
            float: right;
        }

        .color-presets {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .color-preset {
            width: 25px;
            height: 25px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-preset:hover {
            transform: scale(1.1);
        }

        .color-preset.active {
            border-color: #fff;
        }

        .audio-info {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
            font-size: 0.75em;
            color: #888;
            margin-top: 10px;
        }

        .audio-info span {
            color: #ff6b6b;
        }

        #fileInput {
            display: none;
        }

        .file-label {
            display: block;
            padding: 12px;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(254, 202, 87, 0.2));
            border: 1px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .file-label:hover {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.3), rgba(254, 202, 87, 0.3));
            border-color: rgba(255, 255, 255, 0.5);
        }

        .now-playing {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            font-size: 0.75em;
            display: none;
        }

        .now-playing.visible {
            display: block;
        }

        .track-name {
            color: #feca57;
            font-weight: bold;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-controls {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .track-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
        }

        .track-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .help-text {
            font-size: 0.7em;
            color: #555;
            margin-top: 15px;
            line-height: 1.4;
        }

        .fullscreen-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85em;
            z-index: 100;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 107, 107, 0.3);
        }

        .hide-controls {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls" id="controls">
        <h1>Music Visualizer</h1>
        <p class="subtitle">Audio Reactive Graphics</p>

        <div class="section">
            <h3>Audio Source</h3>
            <div class="btn-group">
                <button class="btn active" id="micBtn">üé§ Microphone</button>
                <button class="btn" id="demoBtn">üéµ Demo</button>
            </div>
            <label class="file-label" for="fileInput">
                üìÅ Load Audio File
            </label>
            <input type="file" id="fileInput" accept="audio/*">
            <div class="now-playing" id="nowPlaying">
                <div class="track-name" id="trackName">No track loaded</div>
                <div class="track-controls">
                    <button class="track-btn" id="playPauseBtn">‚ñ∂ Play</button>
                    <button class="track-btn" id="stopBtn">‚èπ Stop</button>
                </div>
            </div>
        </div>

        <div class="section">
            <h3>Visualization</h3>
            <div class="viz-grid">
                <button class="viz-btn active" data-viz="bars">Bars</button>
                <button class="viz-btn" data-viz="circle">Circle</button>
                <button class="viz-btn" data-viz="wave">Waveform</button>
                <button class="viz-btn" data-viz="particles">Particles</button>
                <button class="viz-btn" data-viz="tunnel">Tunnel</button>
                <button class="viz-btn" data-viz="galaxy">Galaxy</button>
                <button class="viz-btn" data-viz="fractal">Fractal</button>
                <button class="viz-btn" data-viz="terrain">Terrain</button>
            </div>
        </div>

        <div class="section">
            <h3>Settings</h3>
            <div class="control-group">
                <label>Sensitivity <span class="value-display" id="sensVal">1.0</span></label>
                <input type="range" id="sensitivity" min="1" max="30" value="10">
            </div>
            <div class="control-group">
                <label>Smoothing <span class="value-display" id="smoothVal">0.8</span></label>
                <input type="range" id="smoothing" min="0" max="95" value="80">
            </div>
            <div class="control-group">
                <label>Speed <span class="value-display" id="speedVal">1.0</span></label>
                <input type="range" id="speed" min="1" max="30" value="10">
            </div>
        </div>

        <div class="section">
            <h3>Colors</h3>
            <div class="color-presets">
                <div class="color-preset active" style="background: linear-gradient(135deg, #ff6b6b, #feca57);" data-scheme="fire"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #00ff88, #00d4ff);" data-scheme="cyber"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #a29bfe, #fd79a8);" data-scheme="vapor"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #74b9ff, #0984e3);" data-scheme="ocean"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #fff, #888);" data-scheme="mono"></div>
            </div>
        </div>

        <div class="audio-info">
            <div>Bass: <span id="bassLevel">0</span></div>
            <div>Mid: <span id="midLevel">0</span></div>
            <div>Treble: <span id="trebleLevel">0</span></div>
        </div>

        <div class="help-text">
            Press H to toggle controls<br>
            Press F for fullscreen
        </div>
    </div>

    <button class="fullscreen-btn" id="fullscreenBtn">‚õ∂ Fullscreen</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let audioContext;
        let analyser;
        let dataArray;
        let frequencyData;
        let source;
        let isPlaying = false;
        let audioElement;

        let currentViz = 'bars';
        let sensitivity = 1.0;
        let smoothing = 0.8;
        let speed = 1.0;
        let time = 0;

        const colorSchemes = {
            fire: {
                colors: ['#ff6b6b', '#feca57', '#ff9f43', '#ee5a24'],
                bg: '#0a0000'
            },
            cyber: {
                colors: ['#00ff88', '#00d4ff', '#7b2cbf', '#00ff88'],
                bg: '#000a0a'
            },
            vapor: {
                colors: ['#a29bfe', '#fd79a8', '#00cec9', '#81ecec'],
                bg: '#0a000a'
            },
            ocean: {
                colors: ['#74b9ff', '#0984e3', '#00cec9', '#0984e3'],
                bg: '#000508'
            },
            mono: {
                colors: ['#ffffff', '#cccccc', '#999999', '#666666'],
                bg: '#000000'
            }
        };

        let currentScheme = colorSchemes.fire;

        // Particles for particle visualization
        let particles = [];
        const maxParticles = 500;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        async function initAudio(useMic = true) {
            if (audioContext) {
                audioContext.close();
            }

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = smoothing;

            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            frequencyData = new Uint8Array(bufferLength);

            if (useMic) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    source = audioContext.createMediaStreamSource(stream);
                    source.connect(analyser);
                    isPlaying = true;
                } catch (err) {
                    console.error('Microphone access denied:', err);
                    alert('Microphone access is required for this feature');
                }
            }
        }

        function playDemo() {
            if (audioContext) audioContext.close();

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = smoothing;

            dataArray = new Uint8Array(analyser.frequencyBinCount);
            frequencyData = new Uint8Array(analyser.frequencyBinCount);

            // Create demo oscillators
            const oscillators = [];
            const gains = [];
            const frequencies = [60, 120, 240, 480, 960, 1920];

            frequencies.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = i % 2 === 0 ? 'sine' : 'triangle';
                osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                gain.gain.setValueAtTime(0, audioContext.currentTime);

                osc.connect(gain);
                gain.connect(analyser);
                gain.connect(audioContext.destination);

                osc.start();
                oscillators.push(osc);
                gains.push(gain);
            });

            // Animate demo
            function animateDemo() {
                if (!isPlaying) return;

                const t = audioContext.currentTime;
                gains.forEach((gain, i) => {
                    const value = Math.sin(t * (0.5 + i * 0.3)) * 0.3 + 0.1;
                    gain.gain.setValueAtTime(Math.max(0, value), audioContext.currentTime);
                });

                requestAnimationFrame(animateDemo);
            }

            isPlaying = true;
            animateDemo();
        }

        function loadAudioFile(file) {
            if (audioElement) {
                audioElement.pause();
                audioElement = null;
            }

            if (audioContext) audioContext.close();

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = smoothing;

            dataArray = new Uint8Array(analyser.frequencyBinCount);
            frequencyData = new Uint8Array(analyser.frequencyBinCount);

            audioElement = new Audio();
            audioElement.src = URL.createObjectURL(file);

            source = audioContext.createMediaElementSource(audioElement);
            source.connect(analyser);
            analyser.connect(audioContext.destination);

            document.getElementById('trackName').textContent = file.name;
            document.getElementById('nowPlaying').classList.add('visible');
            document.getElementById('playPauseBtn').textContent = '‚ñ∂ Play';

            isPlaying = true;
        }

        function getAudioData() {
            if (!analyser) return { bass: 0, mid: 0, treble: 0, waveform: [], frequency: [] };

            analyser.getByteFrequencyData(frequencyData);
            analyser.getByteTimeDomainData(dataArray);

            const bufferLength = analyser.frequencyBinCount;

            // Calculate frequency bands
            let bass = 0, mid = 0, treble = 0;
            const bassEnd = Math.floor(bufferLength * 0.1);
            const midEnd = Math.floor(bufferLength * 0.5);

            for (let i = 0; i < bufferLength; i++) {
                if (i < bassEnd) {
                    bass += frequencyData[i];
                } else if (i < midEnd) {
                    mid += frequencyData[i];
                } else {
                    treble += frequencyData[i];
                }
            }

            bass = (bass / bassEnd) * sensitivity;
            mid = (mid / (midEnd - bassEnd)) * sensitivity;
            treble = (treble / (bufferLength - midEnd)) * sensitivity;

            document.getElementById('bassLevel').textContent = Math.round(bass);
            document.getElementById('midLevel').textContent = Math.round(mid);
            document.getElementById('trebleLevel').textContent = Math.round(treble);

            return {
                bass: bass / 255,
                mid: mid / 255,
                treble: treble / 255,
                waveform: dataArray,
                frequency: frequencyData
            };
        }

        function getColor(index, total) {
            const t = index / total;
            const colors = currentScheme.colors;
            const i = Math.floor(t * (colors.length - 1));
            const f = t * (colors.length - 1) - i;

            const c1 = hexToRgb(colors[i]);
            const c2 = hexToRgb(colors[Math.min(i + 1, colors.length - 1)]);

            const r = Math.round(c1.r + (c2.r - c1.r) * f);
            const g = Math.round(c1.g + (c2.g - c1.g) * f);
            const b = Math.round(c1.b + (c2.b - c1.b) * f);

            return `rgb(${r}, ${g}, ${b})`;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Visualization functions
        function drawBars(data) {
            const { frequency } = data;
            const barCount = 64;
            const barWidth = canvas.width / barCount;
            const step = Math.floor(frequency.length / barCount);

            for (let i = 0; i < barCount; i++) {
                const value = frequency[i * step] * sensitivity / 255;
                const height = value * canvas.height * 0.8;

                const gradient = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - height);
                gradient.addColorStop(0, getColor(i, barCount));
                gradient.addColorStop(1, getColor((i + barCount / 2) % barCount, barCount));

                ctx.fillStyle = gradient;
                ctx.fillRect(
                    i * barWidth + 2,
                    canvas.height - height,
                    barWidth - 4,
                    height
                );

                // Reflection
                ctx.fillStyle = `rgba(${hexToRgb(currentScheme.colors[0]).r}, ${hexToRgb(currentScheme.colors[0]).g}, ${hexToRgb(currentScheme.colors[0]).b}, 0.2)`;
                ctx.fillRect(
                    i * barWidth + 2,
                    canvas.height,
                    barWidth - 4,
                    height * 0.3
                );
            }
        }

        function drawCircle(data) {
            const { frequency, bass, mid, treble } = data;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const baseRadius = Math.min(canvas.width, canvas.height) * 0.2;
            const barCount = 180;

            // Pulsing inner circle
            ctx.beginPath();
            ctx.arc(cx, cy, baseRadius * (0.5 + bass * 0.5), 0, Math.PI * 2);
            ctx.fillStyle = currentScheme.colors[0];
            ctx.globalAlpha = 0.3 + bass * 0.3;
            ctx.fill();
            ctx.globalAlpha = 1;

            // Frequency bars around circle
            for (let i = 0; i < barCount; i++) {
                const angle = (i / barCount) * Math.PI * 2 - Math.PI / 2;
                const freqIndex = Math.floor((i / barCount) * frequency.length);
                const value = frequency[freqIndex] * sensitivity / 255;
                const length = value * baseRadius * 1.5;

                const x1 = cx + Math.cos(angle) * baseRadius;
                const y1 = cy + Math.sin(angle) * baseRadius;
                const x2 = cx + Math.cos(angle) * (baseRadius + length);
                const y2 = cy + Math.sin(angle) * (baseRadius + length);

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = getColor(i, barCount);
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        function drawWave(data) {
            const { waveform, bass } = data;
            const sliceWidth = canvas.width / waveform.length;

            for (let layer = 0; layer < 3; layer++) {
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);

                for (let i = 0; i < waveform.length; i++) {
                    const v = waveform[i] / 128.0;
                    const y = (v * canvas.height / 2) + (layer - 1) * 50 * bass;
                    const x = i * sliceWidth;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.strokeStyle = currentScheme.colors[layer % currentScheme.colors.length];
                ctx.lineWidth = 3 - layer;
                ctx.globalAlpha = 1 - layer * 0.3;
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function drawParticles(data) {
            const { bass, mid, treble } = data;

            // Spawn new particles
            const spawnCount = Math.floor(bass * 10 + mid * 5);
            for (let i = 0; i < spawnCount && particles.length < maxParticles; i++) {
                particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 10 * (1 + bass),
                    vy: (Math.random() - 0.5) * 10 * (1 + mid),
                    size: 2 + Math.random() * 4 * treble,
                    life: 1,
                    color: currentScheme.colors[Math.floor(Math.random() * currentScheme.colors.length)]
                });
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * speed;
                p.y += p.vy * speed;
                p.life -= 0.01 * speed;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }

                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function drawTunnel(data) {
            const { frequency, bass } = data;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const rings = 20;
            const segments = 32;

            for (let ring = rings; ring >= 0; ring--) {
                const ringProgress = ring / rings;
                const baseRadius = (1 - ringProgress) * Math.min(canvas.width, canvas.height) * 0.6;
                const timeOffset = time * speed * 0.001;

                ctx.beginPath();
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2 + timeOffset + ring * 0.1;
                    const freqIndex = Math.floor((i / segments) * frequency.length * 0.5);
                    const freqValue = frequency[freqIndex] * sensitivity / 255;
                    const radius = baseRadius + freqValue * 50 * ringProgress;

                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.closePath();
                ctx.strokeStyle = getColor(ring, rings);
                ctx.lineWidth = 2 + bass * 2;
                ctx.globalAlpha = ringProgress;
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function drawGalaxy(data) {
            const { frequency, bass, mid } = data;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const arms = 5;
            const pointsPerArm = 100;

            for (let arm = 0; arm < arms; arm++) {
                for (let i = 0; i < pointsPerArm; i++) {
                    const progress = i / pointsPerArm;
                    const armAngle = (arm / arms) * Math.PI * 2;
                    const spiralAngle = progress * Math.PI * 4 + time * speed * 0.0005;
                    const angle = armAngle + spiralAngle;

                    const freqIndex = Math.floor(progress * frequency.length * 0.3);
                    const freqValue = frequency[freqIndex] * sensitivity / 255;

                    const radius = progress * Math.min(canvas.width, canvas.height) * 0.4 + freqValue * 30;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;

                    const size = (1 + freqValue * 3) * (1 - progress * 0.5);

                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fillStyle = getColor(Math.floor(progress * 100), 100);
                    ctx.globalAlpha = 0.5 + freqValue * 0.5;
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
        }

        function drawFractal(data) {
            const { frequency, bass, mid, treble } = data;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const depth = 7;

            function drawBranch(x, y, angle, length, d) {
                if (d <= 0 || length < 5) return;

                const freqIndex = Math.floor((d / depth) * frequency.length * 0.3);
                const freqValue = frequency[freqIndex] * sensitivity / 255;

                const endX = x + Math.cos(angle) * length;
                const endY = y + Math.sin(angle) * length;

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = getColor(depth - d, depth);
                ctx.lineWidth = d * 0.5;
                ctx.globalAlpha = 0.5 + freqValue * 0.5;
                ctx.stroke();

                const spread = 0.4 + bass * 0.3;
                const shrink = 0.65 + mid * 0.1;

                drawBranch(endX, endY, angle - spread, length * shrink, d - 1);
                drawBranch(endX, endY, angle + spread, length * shrink, d - 1);
            }

            const baseLength = 80 + bass * 40;
            drawBranch(cx, canvas.height, -Math.PI / 2, baseLength, depth);
            ctx.globalAlpha = 1;
        }

        function drawTerrain(data) {
            const { frequency, bass } = data;
            const rows = 30;
            const cols = 60;
            const cellWidth = canvas.width / cols;
            const cellHeight = canvas.height / rows;

            for (let row = 0; row < rows; row++) {
                ctx.beginPath();

                for (let col = 0; col <= cols; col++) {
                    const freqIndex = Math.floor((col / cols) * frequency.length * 0.5);
                    const freqValue = frequency[freqIndex] * sensitivity / 255;

                    const x = col * cellWidth;
                    const baseY = canvas.height - row * cellHeight * 0.8;
                    const wave = Math.sin((col + time * speed * 0.01) * 0.2) * 20;
                    const y = baseY - freqValue * 100 - wave * (1 + bass);

                    if (col === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.strokeStyle = getColor(row, rows);
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.3 + (row / rows) * 0.7;
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        const visualizations = {
            bars: drawBars,
            circle: drawCircle,
            wave: drawWave,
            particles: drawParticles,
            tunnel: drawTunnel,
            galaxy: drawGalaxy,
            fractal: drawFractal,
            terrain: drawTerrain
        };

        function draw() {
            ctx.fillStyle = currentScheme.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const data = getAudioData();
            time++;

            if (visualizations[currentViz]) {
                visualizations[currentViz](data);
            }

            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('micBtn').addEventListener('click', () => {
            document.querySelectorAll('.btn-group .btn').forEach(b => b.classList.remove('active'));
            document.getElementById('micBtn').classList.add('active');
            document.getElementById('nowPlaying').classList.remove('visible');
            if (audioElement) audioElement.pause();
            initAudio(true);
        });

        document.getElementById('demoBtn').addEventListener('click', () => {
            document.querySelectorAll('.btn-group .btn').forEach(b => b.classList.remove('active'));
            document.getElementById('demoBtn').classList.add('active');
            document.getElementById('nowPlaying').classList.remove('visible');
            if (audioElement) audioElement.pause();
            playDemo();
        });

        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files[0]) {
                document.querySelectorAll('.btn-group .btn').forEach(b => b.classList.remove('active'));
                loadAudioFile(e.target.files[0]);
            }
        });

        document.getElementById('playPauseBtn').addEventListener('click', () => {
            if (audioElement) {
                if (audioElement.paused) {
                    audioElement.play();
                    document.getElementById('playPauseBtn').textContent = '‚è∏ Pause';
                } else {
                    audioElement.pause();
                    document.getElementById('playPauseBtn').textContent = '‚ñ∂ Play';
                }
            }
        });

        document.getElementById('stopBtn').addEventListener('click', () => {
            if (audioElement) {
                audioElement.pause();
                audioElement.currentTime = 0;
                document.getElementById('playPauseBtn').textContent = '‚ñ∂ Play';
            }
        });

        document.querySelectorAll('.viz-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.viz-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentViz = btn.dataset.viz;
                particles = [];
            });
        });

        document.getElementById('sensitivity').addEventListener('input', (e) => {
            sensitivity = e.target.value / 10;
            document.getElementById('sensVal').textContent = sensitivity.toFixed(1);
        });

        document.getElementById('smoothing').addEventListener('input', (e) => {
            smoothing = e.target.value / 100;
            document.getElementById('smoothVal').textContent = smoothing.toFixed(2);
            if (analyser) analyser.smoothingTimeConstant = smoothing;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            speed = e.target.value / 10;
            document.getElementById('speedVal').textContent = speed.toFixed(1);
        });

        document.querySelectorAll('.color-preset').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.color-preset').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentScheme = colorSchemes[btn.dataset.scheme];
            });
        });

        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'h' || e.key === 'H') {
                document.getElementById('controls').classList.toggle('hide-controls');
            } else if (e.key === 'f' || e.key === 'F') {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
            }
        });

        window.addEventListener('resize', resizeCanvas);

        // Initialize
        resizeCanvas();
        initAudio(true);
        draw();
    </script>
</body>
</html>
