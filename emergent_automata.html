<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emergent Automata: Complex Systems from Simple Rules</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0a0a0a;
            color: #e0e0e0;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow: hidden;
            display: flex;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        #canvas {
            display: block;
        }

        .sidebar {
            width: 320px;
            background: linear-gradient(180deg, #111 0%, #0a0a0a 100%);
            border-left: 1px solid #222;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: rgba(30, 30, 30, 0.8);
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
        }

        .panel h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #888;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }

        .rule-display {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
            margin-bottom: 10px;
        }

        .rule-cell {
            aspect-ratio: 1;
            background: #222;
            border-radius: 2px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .rule-cell.active {
            background: #4a9eff;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 11px;
        }

        .stat-label { color: #666; }
        .stat-value { color: #aaa; }
        .stat-value.highlight { color: #4a9eff; }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .btn {
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #252525;
            border-color: #444;
            color: #fff;
        }

        .btn.active {
            background: #1a3a5a;
            border-color: #4a9eff;
            color: #4a9eff;
        }

        .btn.primary {
            grid-column: 1 / -1;
            background: #1a3a5a;
            border-color: #4a9eff;
            color: #4a9eff;
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #666;
            margin-bottom: 5px;
        }

        .slider-group label span {
            color: #aaa;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
        }

        select {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #aaa;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }

        select option {
            background: #1a1a1a;
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .layer-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .layer-toggle label {
            flex: 1;
            font-size: 11px;
            cursor: pointer;
        }

        .layer-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
        }

        .header h1 {
            font-size: 24px;
            font-weight: normal;
            letter-spacing: 3px;
            color: #fff;
            text-shadow: 0 0 20px rgba(74, 158, 255, 0.3);
            margin-bottom: 5px;
        }

        .header .subtitle {
            font-size: 11px;
            color: #666;
            letter-spacing: 2px;
        }

        .info-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 20px;
            font-size: 11px;
            color: #666;
        }

        .info-bar span {
            color: #aaa;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }

        .preset-btn {
            padding: 6px;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #888;
            border-radius: 3px;
            cursor: pointer;
            font-size: 9px;
            text-transform: uppercase;
        }

        .preset-btn:hover {
            background: #252525;
            color: #aaa;
        }

        .analysis-graph {
            height: 60px;
            background: #111;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #population-graph {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        <div class="header">
            <h1>EMERGENT AUTOMATA</h1>
            <div class="subtitle">Complex Systems from Simple Rules</div>
        </div>
        <div class="info-bar">
            <div>Generation: <span id="generation">0</span></div>
            <div>Population: <span id="population">0</span></div>
            <div>Entropy: <span id="entropy">0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <div class="sidebar">
        <div class="panel">
            <h3>Simulation Control</h3>
            <div class="btn-group">
                <button class="btn active" id="play-btn">Play</button>
                <button class="btn" id="step-btn">Step</button>
                <button class="btn" id="clear-btn">Clear</button>
                <button class="btn" id="random-btn">Random</button>
            </div>
            <div class="slider-group" style="margin-top: 15px;">
                <label>Speed <span id="speed-val">10</span> gen/s</label>
                <input type="range" id="speed" min="1" max="60" value="10">
            </div>
        </div>

        <div class="panel">
            <h3>Automaton Type</h3>
            <select id="automaton-type">
                <option value="life">Conway's Game of Life</option>
                <option value="highlife">HighLife (B36/S23)</option>
                <option value="daynight">Day & Night</option>
                <option value="seeds">Seeds</option>
                <option value="brian">Brian's Brain</option>
                <option value="wireworld">Wireworld</option>
                <option value="langton">Langton's Ant</option>
                <option value="lenia">Lenia (Continuous)</option>
                <option value="custom">Custom Rule</option>
            </select>
        </div>

        <div class="panel" id="custom-rule-panel" style="display: none;">
            <h3>Custom Rule (B/S notation)</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <div style="flex: 1;">
                    <label style="font-size: 10px; color: #666;">Birth</label>
                    <input type="text" id="birth-rule" value="3" style="width: 100%; padding: 6px; background: #1a1a1a; border: 1px solid #333; color: #aaa; border-radius: 3px; font-size: 11px;">
                </div>
                <div style="flex: 1;">
                    <label style="font-size: 10px; color: #666;">Survival</label>
                    <input type="text" id="survival-rule" value="23" style="width: 100%; padding: 6px; background: #1a1a1a; border: 1px solid #333; color: #aaa; border-radius: 3px; font-size: 11px;">
                </div>
            </div>
            <button class="btn primary" id="apply-rule">Apply Rule</button>
        </div>

        <div class="panel">
            <h3>Pattern Presets</h3>
            <div class="preset-grid">
                <button class="preset-btn" data-pattern="glider">Glider</button>
                <button class="preset-btn" data-pattern="lwss">LWSS</button>
                <button class="preset-btn" data-pattern="pulsar">Pulsar</button>
                <button class="preset-btn" data-pattern="gosper">Gosper Gun</button>
                <button class="preset-btn" data-pattern="rpentomino">R-pent</button>
                <button class="preset-btn" data-pattern="acorn">Acorn</button>
                <button class="preset-btn" data-pattern="diehard">Diehard</button>
                <button class="preset-btn" data-pattern="spacefiller">Filler</button>
                <button class="preset-btn" data-pattern="random">Soup</button>
            </div>
        </div>

        <div class="panel">
            <h3>Display Layers</h3>
            <div class="layer-toggle">
                <input type="checkbox" id="layer-cells" checked>
                <label for="layer-cells">Living Cells</label>
                <div class="layer-color" style="background: #4a9eff;"></div>
            </div>
            <div class="layer-toggle">
                <input type="checkbox" id="layer-trails">
                <label for="layer-trails">History Trails</label>
                <div class="layer-color" style="background: #2a5a8a;"></div>
            </div>
            <div class="layer-toggle">
                <input type="checkbox" id="layer-heat">
                <label for="layer-heat">Activity Heatmap</label>
                <div class="layer-color" style="background: #ff6a4a;"></div>
            </div>
            <div class="layer-toggle">
                <input type="checkbox" id="layer-age">
                <label for="layer-age">Cell Age Gradient</label>
                <div class="layer-color" style="background: linear-gradient(90deg, #4af, #f4a);"></div>
            </div>
        </div>

        <div class="panel">
            <h3>Grid Settings</h3>
            <div class="slider-group">
                <label>Cell Size <span id="cell-size-val">4</span>px</label>
                <input type="range" id="cell-size" min="1" max="20" value="4">
            </div>
            <div class="btn-group">
                <button class="btn" id="wrap-toggle">Wrap: On</button>
                <button class="btn" id="grid-toggle">Grid: Off</button>
            </div>
        </div>

        <div class="panel">
            <h3>Statistics</h3>
            <div class="stat-row">
                <span class="stat-label">Total Births</span>
                <span class="stat-value" id="total-births">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Deaths</span>
                <span class="stat-value" id="total-deaths">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Peak Population</span>
                <span class="stat-value highlight" id="peak-population">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Stability Index</span>
                <span class="stat-value" id="stability">0%</span>
            </div>
        </div>

        <div class="panel">
            <h3>Population History</h3>
            <div class="analysis-graph">
                <canvas id="population-graph"></canvas>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // EMERGENT AUTOMATA ENGINE
        // ============================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('population-graph');
        const graphCtx = graphCanvas.getContext('2d');

        // Simulation state
        let grid = [];
        let nextGrid = [];
        let ageGrid = [];
        let heatGrid = [];
        let antGrid = [];  // For Langton's ant
        let antX, antY, antDir;  // Ant position and direction
        let brianGrid = [];  // For Brian's Brain (dying state)

        let cellSize = 4;
        let cols, rows;
        let generation = 0;
        let population = 0;
        let totalBirths = 0;
        let totalDeaths = 0;
        let peakPopulation = 0;
        let populationHistory = [];
        let isPlaying = true;
        let speed = 10;
        let wrap = true;
        let showGrid = false;

        // Layers
        let showCells = true;
        let showTrails = false;
        let showHeat = false;
        let showAge = false;

        // Rules
        let currentRule = 'life';
        let birthRule = [3];
        let survivalRule = [2, 3];

        // Lenia parameters
        let leniaGrid = [];
        let leniaKernel = [];

        // Performance
        let lastFrameTime = 0;
        let frameCount = 0;
        let fps = 0;

        // ============================================
        // PATTERNS
        // ============================================

        const patterns = {
            glider: [[0,1,0],[0,0,1],[1,1,1]],
            lwss: [[0,1,1,1,1],[1,0,0,0,1],[0,0,0,0,1],[1,0,0,1,0]],
            pulsar: [
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,0,0,0,1,1,1,0,0]
            ],
            gosper: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            rpentomino: [[0,1,1],[1,1,0],[0,1,0]],
            acorn: [[0,1,0,0,0,0,0],[0,0,0,1,0,0,0],[1,1,0,0,1,1,1]],
            diehard: [[0,0,0,0,0,0,1,0],[1,1,0,0,0,0,0,0],[0,1,0,0,0,1,1,1]],
            spacefiller: [[0,0,0,1,0,0,0],[0,0,1,0,1,0,0],[0,1,0,0,0,1,0],[1,0,0,0,0,0,1]],
        };

        // ============================================
        // INITIALIZATION
        // ============================================

        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            graphCanvas.width = graphCanvas.parentElement.clientWidth;
            graphCanvas.height = 60;

            cols = Math.ceil(canvas.width / cellSize);
            rows = Math.ceil(canvas.height / cellSize);

            initGrids();
        }

        function initGrids() {
            grid = Array(rows).fill(null).map(() => Array(cols).fill(0));
            nextGrid = Array(rows).fill(null).map(() => Array(cols).fill(0));
            ageGrid = Array(rows).fill(null).map(() => Array(cols).fill(0));
            heatGrid = Array(rows).fill(null).map(() => Array(cols).fill(0));
            brianGrid = Array(rows).fill(null).map(() => Array(cols).fill(0));
            leniaGrid = Array(rows).fill(null).map(() => Array(cols).fill(0));

            // Initialize ant in center
            antX = Math.floor(cols / 2);
            antY = Math.floor(rows / 2);
            antDir = 0; // 0=up, 1=right, 2=down, 3=left

            initLeniaKernel();
        }

        function initLeniaKernel() {
            const kernelSize = 13;
            leniaKernel = [];
            const center = Math.floor(kernelSize / 2);

            for (let y = 0; y < kernelSize; y++) {
                leniaKernel[y] = [];
                for (let x = 0; x < kernelSize; x++) {
                    const dist = Math.sqrt((x - center) ** 2 + (y - center) ** 2) / center;
                    leniaKernel[y][x] = Math.exp(-((dist - 0.5) ** 2) / 0.15);
                }
            }
        }

        // ============================================
        // RULES
        // ============================================

        function setRule(ruleName) {
            currentRule = ruleName;

            switch (ruleName) {
                case 'life':
                    birthRule = [3];
                    survivalRule = [2, 3];
                    break;
                case 'highlife':
                    birthRule = [3, 6];
                    survivalRule = [2, 3];
                    break;
                case 'daynight':
                    birthRule = [3, 6, 7, 8];
                    survivalRule = [3, 4, 6, 7, 8];
                    break;
                case 'seeds':
                    birthRule = [2];
                    survivalRule = [];
                    break;
            }
        }

        function countNeighbors(x, y) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    let nx = x + dx;
                    let ny = y + dy;

                    if (wrap) {
                        nx = (nx + cols) % cols;
                        ny = (ny + rows) % rows;
                    } else if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) {
                        continue;
                    }

                    if (grid[ny][nx]) count++;
                }
            }
            return count;
        }

        // ============================================
        // SIMULATION STEP
        // ============================================

        function step() {
            generation++;
            let births = 0;
            let deaths = 0;

            // Decay heat
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    heatGrid[y][x] *= 0.95;
                }
            }

            switch (currentRule) {
                case 'brian':
                    stepBriansBrain();
                    break;
                case 'wireworld':
                    stepWireworld();
                    break;
                case 'langton':
                    stepLangtonsAnt();
                    break;
                case 'lenia':
                    stepLenia();
                    break;
                default:
                    stepLifeLike();
            }

            // Swap grids
            [grid, nextGrid] = [nextGrid, grid];

            // Count population and update stats
            population = 0;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (grid[y][x]) {
                        population++;
                        ageGrid[y][x]++;
                    } else {
                        ageGrid[y][x] = 0;
                    }
                }
            }

            if (population > peakPopulation) {
                peakPopulation = population;
            }

            populationHistory.push(population);
            if (populationHistory.length > 200) {
                populationHistory.shift();
            }
        }

        function stepLifeLike() {
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const neighbors = countNeighbors(x, y);
                    const alive = grid[y][x];

                    if (alive) {
                        nextGrid[y][x] = survivalRule.includes(neighbors) ? 1 : 0;
                        if (!nextGrid[y][x]) {
                            totalDeaths++;
                            heatGrid[y][x] = 1;
                        }
                    } else {
                        nextGrid[y][x] = birthRule.includes(neighbors) ? 1 : 0;
                        if (nextGrid[y][x]) {
                            totalBirths++;
                            heatGrid[y][x] = 1;
                        }
                    }
                }
            }
        }

        function stepBriansBrain() {
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (grid[y][x] === 1) {
                        // Alive -> Dying
                        nextGrid[y][x] = 2;
                        brianGrid[y][x] = 1;
                    } else if (grid[y][x] === 2 || brianGrid[y][x]) {
                        // Dying -> Dead
                        nextGrid[y][x] = 0;
                        brianGrid[y][x] = 0;
                    } else {
                        // Dead -> maybe Alive
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                let nx = (x + dx + cols) % cols;
                                let ny = (y + dy + rows) % rows;
                                if (grid[ny][nx] === 1) count++;
                            }
                        }
                        nextGrid[y][x] = count === 2 ? 1 : 0;
                        if (nextGrid[y][x]) heatGrid[y][x] = 1;
                    }
                }
            }
        }

        function stepWireworld() {
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const state = grid[y][x];

                    if (state === 0) {
                        // Empty stays empty
                        nextGrid[y][x] = 0;
                    } else if (state === 1) {
                        // Electron head -> tail
                        nextGrid[y][x] = 2;
                    } else if (state === 2) {
                        // Electron tail -> conductor
                        nextGrid[y][x] = 3;
                    } else {
                        // Conductor: becomes head if 1 or 2 head neighbors
                        let heads = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                let nx = (x + dx + cols) % cols;
                                let ny = (y + dy + rows) % rows;
                                if (grid[ny][nx] === 1) heads++;
                            }
                        }
                        nextGrid[y][x] = (heads === 1 || heads === 2) ? 1 : 3;
                    }
                }
            }
        }

        function stepLangtonsAnt() {
            // Copy grid
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    nextGrid[y][x] = grid[y][x];
                }
            }

            // Ant movement
            for (let i = 0; i < 10; i++) { // Multiple steps per frame
                const currentCell = grid[antY][antX];

                if (currentCell) {
                    // White: turn right
                    antDir = (antDir + 1) % 4;
                    nextGrid[antY][antX] = 0;
                } else {
                    // Black: turn left
                    antDir = (antDir + 3) % 4;
                    nextGrid[antY][antX] = 1;
                }

                heatGrid[antY][antX] = 1;

                // Move forward
                const dx = [0, 1, 0, -1];
                const dy = [-1, 0, 1, 0];
                antX = (antX + dx[antDir] + cols) % cols;
                antY = (antY + dy[antDir] + rows) % rows;
            }
        }

        function stepLenia() {
            const kernelSize = leniaKernel.length;
            const half = Math.floor(kernelSize / 2);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let sum = 0;
                    let kernelSum = 0;

                    for (let ky = 0; ky < kernelSize; ky++) {
                        for (let kx = 0; kx < kernelSize; kx++) {
                            const nx = (x + kx - half + cols) % cols;
                            const ny = (y + ky - half + rows) % rows;
                            sum += leniaGrid[ny][nx] * leniaKernel[ky][kx];
                            kernelSum += leniaKernel[ky][kx];
                        }
                    }

                    const potential = sum / kernelSum;
                    const growth = 2 * Math.exp(-((potential - 0.35) ** 2) / 0.015) - 1;
                    const newVal = leniaGrid[y][x] + growth * 0.1;

                    nextGrid[y][x] = Math.max(0, Math.min(1, newVal));
                }
            }

            // Copy to leniaGrid and regular grid
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    leniaGrid[y][x] = nextGrid[y][x];
                    grid[y][x] = nextGrid[y][x] > 0.5 ? 1 : 0;
                }
            }
        }

        // ============================================
        // RENDERING
        // ============================================

        function render() {
            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid lines
            if (showGrid && cellSize > 3) {
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 1;
                for (let x = 0; x <= cols; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * cellSize, 0);
                    ctx.lineTo(x * cellSize, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y <= rows; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * cellSize);
                    ctx.lineTo(canvas.width, y * cellSize);
                    ctx.stroke();
                }
            }

            // Draw layers
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const px = x * cellSize;
                    const py = y * cellSize;

                    // Heat layer (behind)
                    if (showHeat && heatGrid[y][x] > 0.01) {
                        const heat = heatGrid[y][x];
                        ctx.fillStyle = `rgba(255, ${Math.floor(100 * (1 - heat))}, ${Math.floor(50 * (1 - heat))}, ${heat * 0.5})`;
                        ctx.fillRect(px, py, cellSize, cellSize);
                    }

                    // Trails layer
                    if (showTrails && ageGrid[y][x] === 0 && grid[y][x] === 0) {
                        // Check if recently alive
                    }

                    // Cell layer
                    if (grid[y][x]) {
                        if (currentRule === 'wireworld') {
                            // Wireworld colors
                            const state = grid[y][x];
                            if (state === 1) ctx.fillStyle = '#4af';  // Head
                            else if (state === 2) ctx.fillStyle = '#f44';  // Tail
                            else if (state === 3) ctx.fillStyle = '#fa0';  // Wire
                        } else if (currentRule === 'brian' && grid[y][x] === 2) {
                            ctx.fillStyle = '#f66';  // Dying
                        } else if (currentRule === 'lenia') {
                            const val = leniaGrid[y][x];
                            ctx.fillStyle = `hsl(200, 80%, ${val * 60}%)`;
                        } else if (showAge) {
                            // Age gradient
                            const age = Math.min(ageGrid[y][x], 100);
                            const hue = 200 - age * 1.5;
                            ctx.fillStyle = `hsl(${hue}, 80%, 55%)`;
                        } else {
                            ctx.fillStyle = '#4a9eff';
                        }

                        if (cellSize > 2) {
                            ctx.fillRect(px + 1, py + 1, cellSize - 2, cellSize - 2);
                        } else {
                            ctx.fillRect(px, py, cellSize, cellSize);
                        }
                    }
                }
            }

            // Draw ant for Langton's ant
            if (currentRule === 'langton') {
                ctx.fillStyle = '#f44';
                ctx.fillRect(antX * cellSize, antY * cellSize, cellSize, cellSize);
            }

            // Update stats
            updateStats();
            drawPopulationGraph();
        }

        function updateStats() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('population').textContent = population;
            document.getElementById('total-births').textContent = totalBirths;
            document.getElementById('total-deaths').textContent = totalDeaths;
            document.getElementById('peak-population').textContent = peakPopulation;

            // Calculate entropy
            const totalCells = rows * cols;
            const p = population / totalCells;
            const entropy = p > 0 && p < 1 ? -p * Math.log2(p) - (1-p) * Math.log2(1-p) : 0;
            document.getElementById('entropy').textContent = entropy.toFixed(3);

            // Calculate stability
            if (populationHistory.length > 10) {
                const recent = populationHistory.slice(-10);
                const variance = recent.reduce((sum, val) => {
                    const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
                    return sum + (val - mean) ** 2;
                }, 0) / recent.length;
                const stability = Math.max(0, 100 - variance / 10);
                document.getElementById('stability').textContent = stability.toFixed(1) + '%';
            }

            // FPS
            frameCount++;
            const now = performance.now();
            if (now - lastFrameTime > 1000) {
                fps = Math.round(frameCount * 1000 / (now - lastFrameTime));
                frameCount = 0;
                lastFrameTime = now;
            }
            document.getElementById('fps').textContent = fps;
        }

        function drawPopulationGraph() {
            graphCtx.fillStyle = '#111';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);

            if (populationHistory.length < 2) return;

            const max = Math.max(...populationHistory, 1);
            const step = graphCanvas.width / (populationHistory.length - 1);

            graphCtx.beginPath();
            graphCtx.moveTo(0, graphCanvas.height - (populationHistory[0] / max) * graphCanvas.height);

            for (let i = 1; i < populationHistory.length; i++) {
                const x = i * step;
                const y = graphCanvas.height - (populationHistory[i] / max) * graphCanvas.height;
                graphCtx.lineTo(x, y);
            }

            graphCtx.strokeStyle = '#4a9eff';
            graphCtx.lineWidth = 1;
            graphCtx.stroke();
        }

        // ============================================
        // PATTERNS
        // ============================================

        function placePattern(pattern, cx, cy) {
            const height = pattern.length;
            const width = pattern[0].length;
            const startX = cx - Math.floor(width / 2);
            const startY = cy - Math.floor(height / 2);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const gx = (startX + x + cols) % cols;
                    const gy = (startY + y + rows) % rows;
                    if (pattern[y][x]) {
                        grid[gy][gx] = 1;
                        if (currentRule === 'lenia') {
                            leniaGrid[gy][gx] = 1;
                        }
                    }
                }
            }
        }

        function randomize(density = 0.3) {
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const val = Math.random() < density ? 1 : 0;
                    grid[y][x] = val;
                    if (currentRule === 'lenia') {
                        leniaGrid[y][x] = Math.random() < density ? Math.random() : 0;
                    }
                }
            }
            generation = 0;
            totalBirths = 0;
            totalDeaths = 0;
            peakPopulation = 0;
            populationHistory = [];
        }

        function clear() {
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    grid[y][x] = 0;
                    nextGrid[y][x] = 0;
                    ageGrid[y][x] = 0;
                    heatGrid[y][x] = 0;
                    brianGrid[y][x] = 0;
                    leniaGrid[y][x] = 0;
                }
            }
            generation = 0;
            population = 0;
            totalBirths = 0;
            totalDeaths = 0;
            peakPopulation = 0;
            populationHistory = [];

            antX = Math.floor(cols / 2);
            antY = Math.floor(rows / 2);
            antDir = 0;
        }

        // ============================================
        // MAIN LOOP
        // ============================================

        let lastStepTime = 0;

        function gameLoop(timestamp) {
            const stepInterval = 1000 / speed;

            if (isPlaying && timestamp - lastStepTime > stepInterval) {
                step();
                lastStepTime = timestamp;
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        function init() {
            resize();
            window.addEventListener('resize', resize);

            // Canvas interaction
            let isDrawing = false;
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                handleDraw(e);
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isDrawing) handleDraw(e);
            });
            canvas.addEventListener('mouseup', () => isDrawing = false);
            canvas.addEventListener('mouseleave', () => isDrawing = false);

            function handleDraw(e) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / cellSize);
                const y = Math.floor((e.clientY - rect.top) / cellSize);

                if (x >= 0 && x < cols && y >= 0 && y < rows) {
                    if (e.shiftKey) {
                        grid[y][x] = 0;
                        leniaGrid[y][x] = 0;
                    } else {
                        grid[y][x] = 1;
                        leniaGrid[y][x] = 1;
                        if (currentRule === 'wireworld') {
                            grid[y][x] = 3; // Wire
                        }
                    }
                }
            }

            // Controls
            document.getElementById('play-btn').addEventListener('click', () => {
                isPlaying = !isPlaying;
                document.getElementById('play-btn').textContent = isPlaying ? 'Pause' : 'Play';
                document.getElementById('play-btn').classList.toggle('active', isPlaying);
            });

            document.getElementById('step-btn').addEventListener('click', () => {
                step();
            });

            document.getElementById('clear-btn').addEventListener('click', clear);
            document.getElementById('random-btn').addEventListener('click', () => randomize());

            document.getElementById('speed').addEventListener('input', (e) => {
                speed = parseInt(e.target.value);
                document.getElementById('speed-val').textContent = speed;
            });

            document.getElementById('cell-size').addEventListener('input', (e) => {
                cellSize = parseInt(e.target.value);
                document.getElementById('cell-size-val').textContent = cellSize;
                resize();
            });

            document.getElementById('automaton-type').addEventListener('change', (e) => {
                setRule(e.target.value);
                document.getElementById('custom-rule-panel').style.display =
                    e.target.value === 'custom' ? 'block' : 'none';
                clear();
            });

            document.getElementById('apply-rule').addEventListener('click', () => {
                const birth = document.getElementById('birth-rule').value.split('').map(Number).filter(n => !isNaN(n));
                const survival = document.getElementById('survival-rule').value.split('').map(Number).filter(n => !isNaN(n));
                birthRule = birth;
                survivalRule = survival;
            });

            document.getElementById('wrap-toggle').addEventListener('click', (e) => {
                wrap = !wrap;
                e.target.textContent = `Wrap: ${wrap ? 'On' : 'Off'}`;
            });

            document.getElementById('grid-toggle').addEventListener('click', (e) => {
                showGrid = !showGrid;
                e.target.textContent = `Grid: ${showGrid ? 'On' : 'Off'}`;
            });

            // Layers
            document.getElementById('layer-cells').addEventListener('change', (e) => showCells = e.target.checked);
            document.getElementById('layer-trails').addEventListener('change', (e) => showTrails = e.target.checked);
            document.getElementById('layer-heat').addEventListener('change', (e) => showHeat = e.target.checked);
            document.getElementById('layer-age').addEventListener('change', (e) => showAge = e.target.checked);

            // Patterns
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const patternName = btn.dataset.pattern;
                    if (patternName === 'random') {
                        randomize(0.3);
                    } else if (patterns[patternName]) {
                        placePattern(patterns[patternName], Math.floor(cols / 2), Math.floor(rows / 2));
                    }
                });
            });

            // Initial setup
            setRule('life');
            randomize(0.15);

            requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>
