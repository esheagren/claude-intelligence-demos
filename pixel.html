<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            display: flex;
            overflow: hidden;
        }

        .toolbar {
            width: 60px;
            background: #0d0d1a;
            padding: 15px 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-right: 1px solid #333;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            background: #252540;
            border: none;
            border-radius: 8px;
            color: #888;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: #353560;
            color: #fff;
        }

        .tool-btn.active {
            background: #ffd700;
            color: #000;
        }

        .tool-btn[title]:hover::after {
            content: attr(title);
            position: absolute;
            left: 55px;
            background: #000;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 100;
        }

        .sidebar {
            width: 250px;
            background: #0d0d1a;
            padding: 15px;
            overflow-y: auto;
            border-left: 1px solid #333;
        }

        .sidebar h3 {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .color-preview {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .preview-box {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: 2px solid #333;
        }

        .preview-label {
            font-size: 10px;
            color: #666;
            text-align: center;
            margin-top: 4px;
        }

        .color-picker-container {
            margin-bottom: 15px;
        }

        .color-picker-container input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-bottom: 15px;
        }

        .palette-color {
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .palette-color:hover {
            transform: scale(1.1);
        }

        .palette-color.active {
            border-color: #fff;
        }

        .divider {
            height: 1px;
            background: #333;
            margin: 15px 0;
        }

        .size-control {
            margin-bottom: 15px;
        }

        .size-control label {
            display: block;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }

        .size-control input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .size-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
        }

        .size-display {
            text-align: center;
            font-size: 14px;
            color: #ffd700;
            margin-top: 5px;
        }

        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            padding: 10px;
            background: #252540;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        button:hover {
            background: #353560;
        }

        button.primary {
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            color: #000;
            font-weight: bold;
        }

        button.danger {
            background: #c0392b;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #16162a;
            overflow: auto;
            position: relative;
        }

        .canvas-container {
            position: relative;
            background: repeating-conic-gradient(#2a2a4a 0% 25%, #1e1e3a 0% 50%) 50% / 20px 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #pixelCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: crosshair;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 20px;
        }

        .zoom-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #333;
            color: #fff;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }

        .zoom-btn:hover {
            background: #444;
        }

        .zoom-display {
            display: flex;
            align-items: center;
            color: #888;
            font-size: 14px;
            min-width: 50px;
            justify-content: center;
        }

        .layers-panel {
            margin-top: 15px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #252540;
            border-radius: 6px;
            margin-bottom: 5px;
            cursor: pointer;
        }

        .layer-item.active {
            background: #353560;
            border: 1px solid #ffd700;
        }

        .layer-preview {
            width: 30px;
            height: 30px;
            background: #1a1a2e;
            border-radius: 4px;
        }

        .layer-name {
            flex: 1;
            font-size: 12px;
        }

        .layer-visibility {
            font-size: 14px;
            opacity: 0.5;
        }

        .layer-visibility.visible {
            opacity: 1;
        }

        .canvas-size-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .canvas-size-controls input {
            width: 60px;
            padding: 8px;
            background: #252540;
            border: none;
            border-radius: 6px;
            color: #fff;
            text-align: center;
        }

        .canvas-size-controls span {
            display: flex;
            align-items: center;
            color: #888;
        }

        select {
            width: 100%;
            padding: 8px;
            background: #252540;
            color: #fff;
            border: none;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .coordinates {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #888;
            font-family: monospace;
        }

        .keyboard-shortcuts {
            font-size: 10px;
            color: #666;
            margin-top: 15px;
        }

        .keyboard-shortcuts div {
            margin-bottom: 3px;
        }

        .keyboard-shortcuts kbd {
            background: #333;
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="tool-btn active" data-tool="pencil" title="Pencil (P)">‚úè</button>
        <button class="tool-btn" data-tool="eraser" title="Eraser (E)">üßπ</button>
        <button class="tool-btn" data-tool="fill" title="Fill (F)">ü™£</button>
        <button class="tool-btn" data-tool="line" title="Line (L)">üìè</button>
        <button class="tool-btn" data-tool="rect" title="Rectangle (R)">‚¨ú</button>
        <button class="tool-btn" data-tool="circle" title="Circle (C)">‚≠ï</button>
        <button class="tool-btn" data-tool="eyedropper" title="Eyedropper (I)">üíâ</button>
        <button class="tool-btn" data-tool="move" title="Move (M)">‚úã</button>
        <div style="flex: 1;"></div>
        <button class="tool-btn" id="toggleGrid" title="Toggle Grid (G)">‚ñ¶</button>
    </div>

    <div class="canvas-area">
        <div class="coordinates" id="coordinates">X: 0, Y: 0</div>
        <div class="canvas-container" id="canvasContainer">
            <canvas id="pixelCanvas"></canvas>
            <canvas class="grid-overlay" id="gridOverlay"></canvas>
        </div>
        <div class="zoom-controls">
            <button class="zoom-btn" id="zoomOut">‚àí</button>
            <div class="zoom-display" id="zoomDisplay">100%</div>
            <button class="zoom-btn" id="zoomIn">+</button>
        </div>
    </div>

    <div class="sidebar">
        <h3>Colors</h3>
        <div class="color-preview">
            <div>
                <div class="preview-box" id="foregroundPreview" style="background: #ffffff;"></div>
                <div class="preview-label">Primary</div>
            </div>
            <div>
                <div class="preview-box" id="backgroundPreview" style="background: #000000;"></div>
                <div class="preview-label">Secondary</div>
            </div>
        </div>

        <div class="color-picker-container">
            <input type="color" id="colorPicker" value="#ffffff">
        </div>

        <div class="palette" id="palette"></div>

        <div class="control-group">
            <label>Palette</label>
            <select id="paletteSelect">
                <option value="default">Default</option>
                <option value="gameboy">GameBoy</option>
                <option value="nes">NES</option>
                <option value="pico8">PICO-8</option>
                <option value="grayscale">Grayscale</option>
            </select>
        </div>

        <div class="divider"></div>

        <h3>Brush</h3>
        <div class="size-control">
            <label>Size</label>
            <input type="range" id="brushSize" min="1" max="10" value="1">
            <div class="size-display" id="sizeDisplay">1px</div>
        </div>

        <div class="divider"></div>

        <h3>Canvas</h3>
        <div class="canvas-size-controls">
            <input type="number" id="canvasWidth" value="32" min="1" max="256">
            <span>√ó</span>
            <input type="number" id="canvasHeight" value="32" min="1" max="256">
            <button id="resizeCanvas">Apply</button>
        </div>

        <select id="canvasPreset">
            <option value="">Custom Size</option>
            <option value="16">16√ó16</option>
            <option value="32" selected>32√ó32</option>
            <option value="64">64√ó64</option>
            <option value="128">128√ó128</option>
        </select>

        <div class="divider"></div>

        <h3>Actions</h3>
        <div class="btn-grid">
            <button id="undoBtn">Undo</button>
            <button id="redoBtn">Redo</button>
            <button class="danger" id="clearBtn">Clear</button>
            <button id="flipH">Flip H</button>
            <button id="flipV">Flip V</button>
            <button id="rotate">Rotate</button>
        </div>

        <div class="divider"></div>

        <div class="btn-grid">
            <button class="primary" id="exportBtn">Export PNG</button>
            <button id="importBtn">Import</button>
        </div>
        <input type="file" id="importInput" accept="image/*" style="display: none;">

        <div class="divider"></div>

        <div class="keyboard-shortcuts">
            <h3>Shortcuts</h3>
            <div><kbd>P</kbd> Pencil</div>
            <div><kbd>E</kbd> Eraser</div>
            <div><kbd>F</kbd> Fill</div>
            <div><kbd>L</kbd> Line</div>
            <div><kbd>R</kbd> Rectangle</div>
            <div><kbd>C</kbd> Circle</div>
            <div><kbd>I</kbd> Eyedropper</div>
            <div><kbd>G</kbd> Toggle Grid</div>
            <div><kbd>Ctrl+Z</kbd> Undo</div>
            <div><kbd>Ctrl+Y</kbd> Redo</div>
            <div><kbd>+/-</kbd> Zoom</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const gridCanvas = document.getElementById('gridOverlay');
        const gridCtx = gridCanvas.getContext('2d');
        const container = document.getElementById('canvasContainer');

        let canvasWidth = 32;
        let canvasHeight = 32;
        let zoom = 10;
        let showGrid = true;

        let currentTool = 'pencil';
        let foregroundColor = '#ffffff';
        let backgroundColor = '#000000';
        let brushSize = 1;

        let isDrawing = false;
        let startX, startY;
        let lastX, lastY;

        let history = [];
        let historyIndex = -1;
        const maxHistory = 50;

        // Color palettes
        const palettes = {
            default: [
                '#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff',
                '#800000', '#008000', '#000080', '#808000', '#800080', '#008080', '#c0c0c0', '#808080',
                '#ff8080', '#80ff80', '#8080ff', '#ffff80', '#ff80ff', '#80ffff', '#ffd700', '#ff8c00'
            ],
            gameboy: ['#0f380f', '#306230', '#8bac0f', '#9bbc0f'],
            nes: [
                '#000000', '#fcfcfc', '#f8f8f8', '#bcbcbc', '#7c7c7c', '#a4e4fc', '#3cbcfc', '#0078f8',
                '#0000fc', '#b8b8f8', '#6888fc', '#0058f8', '#0000bc', '#d8b8f8', '#9878f8', '#6844fc',
                '#4428bc', '#f8b8f8', '#f878f8', '#d800cc', '#940084', '#f8a4c0', '#f85898', '#e40058',
                '#a80020', '#f0d0b0', '#f87858', '#f83800', '#a81000', '#fce0a8', '#fca044', '#e45c10'
            ],
            pico8: [
                '#000000', '#1d2b53', '#7e2553', '#008751', '#ab5236', '#5f574f', '#c2c3c7', '#fff1e8',
                '#ff004d', '#ffa300', '#ffec27', '#00e436', '#29adff', '#83769c', '#ff77a8', '#ffccaa'
            ],
            grayscale: [
                '#000000', '#111111', '#222222', '#333333', '#444444', '#555555', '#666666', '#777777',
                '#888888', '#999999', '#aaaaaa', '#bbbbbb', '#cccccc', '#dddddd', '#eeeeee', '#ffffff'
            ]
        };

        let currentPalette = 'default';

        function initCanvas() {
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            gridCanvas.width = canvasWidth * zoom;
            gridCanvas.height = canvasHeight * zoom;

            canvas.style.width = canvasWidth * zoom + 'px';
            canvas.style.height = canvasHeight * zoom + 'px';
            gridCanvas.style.width = canvasWidth * zoom + 'px';
            gridCanvas.style.height = canvasHeight * zoom + 'px';

            ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = 'transparent';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            drawGrid();
            saveState();
        }

        function drawGrid() {
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

            if (!showGrid || zoom < 4) return;

            gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            gridCtx.lineWidth = 1;

            for (let x = 0; x <= canvasWidth; x++) {
                gridCtx.beginPath();
                gridCtx.moveTo(x * zoom + 0.5, 0);
                gridCtx.lineTo(x * zoom + 0.5, canvasHeight * zoom);
                gridCtx.stroke();
            }

            for (let y = 0; y <= canvasHeight; y++) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y * zoom + 0.5);
                gridCtx.lineTo(canvasWidth * zoom, y * zoom + 0.5);
                gridCtx.stroke();
            }
        }

        function saveState() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            history.push(canvas.toDataURL());
            if (history.length > maxHistory) {
                history.shift();
            }
            historyIndex = history.length - 1;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadState(history[historyIndex]);
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(history[historyIndex]);
            }
        }

        function loadState(dataUrl) {
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                ctx.drawImage(img, 0, 0);
            };
            img.src = dataUrl;
        }

        function getPixelCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / zoom);
            const y = Math.floor((e.clientY - rect.top) / zoom);
            return { x: Math.max(0, Math.min(x, canvasWidth - 1)), y: Math.max(0, Math.min(y, canvasHeight - 1)) };
        }

        function drawPixel(x, y, color) {
            if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) return;

            ctx.fillStyle = color;
            const halfBrush = Math.floor(brushSize / 2);

            for (let dx = -halfBrush; dx < brushSize - halfBrush; dx++) {
                for (let dy = -halfBrush; dy < brushSize - halfBrush; dy++) {
                    const px = x + dx;
                    const py = y + dy;
                    if (px >= 0 && px < canvasWidth && py >= 0 && py < canvasHeight) {
                        ctx.fillRect(px, py, 1, 1);
                    }
                }
            }
        }

        function erasePixel(x, y) {
            const halfBrush = Math.floor(brushSize / 2);
            for (let dx = -halfBrush; dx < brushSize - halfBrush; dx++) {
                for (let dy = -halfBrush; dy < brushSize - halfBrush; dy++) {
                    const px = x + dx;
                    const py = y + dy;
                    if (px >= 0 && px < canvasWidth && py >= 0 && py < canvasHeight) {
                        ctx.clearRect(px, py, 1, 1);
                    }
                }
            }
        }

        function drawLine(x0, y0, x1, y1, color) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                drawPixel(x0, y0, color);

                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }

        function drawRect(x0, y0, x1, y1, color, filled = false) {
            const minX = Math.min(x0, x1);
            const maxX = Math.max(x0, x1);
            const minY = Math.min(y0, y1);
            const maxY = Math.max(y0, y1);

            if (filled) {
                ctx.fillStyle = color;
                ctx.fillRect(minX, minY, maxX - minX + 1, maxY - minY + 1);
            } else {
                drawLine(minX, minY, maxX, minY, color);
                drawLine(maxX, minY, maxX, maxY, color);
                drawLine(maxX, maxY, minX, maxY, color);
                drawLine(minX, maxY, minX, minY, color);
            }
        }

        function drawCircle(x0, y0, x1, y1, color) {
            const radius = Math.floor(Math.sqrt((x1 - x0) ** 2 + (y1 - y0) ** 2));
            let x = radius;
            let y = 0;
            let err = 0;

            while (x >= y) {
                drawPixel(x0 + x, y0 + y, color);
                drawPixel(x0 + y, y0 + x, color);
                drawPixel(x0 - y, y0 + x, color);
                drawPixel(x0 - x, y0 + y, color);
                drawPixel(x0 - x, y0 - y, color);
                drawPixel(x0 - y, y0 - x, color);
                drawPixel(x0 + y, y0 - x, color);
                drawPixel(x0 + x, y0 - y, color);

                y++;
                if (err <= 0) {
                    err += 2 * y + 1;
                }
                if (err > 0) {
                    x--;
                    err -= 2 * x + 1;
                }
            }
        }

        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            const data = imageData.data;

            const startIdx = (startY * canvasWidth + startX) * 4;
            const startR = data[startIdx];
            const startG = data[startIdx + 1];
            const startB = data[startIdx + 2];
            const startA = data[startIdx + 3];

            // Parse fill color
            const fillR = parseInt(fillColor.slice(1, 3), 16);
            const fillG = parseInt(fillColor.slice(3, 5), 16);
            const fillB = parseInt(fillColor.slice(5, 7), 16);

            // Check if start color is same as fill color
            if (startR === fillR && startG === fillG && startB === fillB && startA === 255) {
                return;
            }

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) continue;

                const idx = (y * canvasWidth + x) * 4;
                if (data[idx] !== startR || data[idx + 1] !== startG ||
                    data[idx + 2] !== startB || data[idx + 3] !== startA) {
                    continue;
                }

                visited.add(key);
                data[idx] = fillR;
                data[idx + 1] = fillG;
                data[idx + 2] = fillB;
                data[idx + 3] = 255;

                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function getPixelColor(x, y) {
            const imageData = ctx.getImageData(x, y, 1, 1);
            const data = imageData.data;
            if (data[3] === 0) return null;
            return '#' + [data[0], data[1], data[2]].map(v => v.toString(16).padStart(2, '0')).join('');
        }

        function setZoom(newZoom) {
            zoom = Math.max(1, Math.min(40, newZoom));
            canvas.style.width = canvasWidth * zoom + 'px';
            canvas.style.height = canvasHeight * zoom + 'px';
            gridCanvas.width = canvasWidth * zoom;
            gridCanvas.height = canvasHeight * zoom;
            gridCanvas.style.width = canvasWidth * zoom + 'px';
            gridCanvas.style.height = canvasHeight * zoom + 'px';
            drawGrid();
            document.getElementById('zoomDisplay').textContent = Math.round(zoom * 100 / 10) + '%';
        }

        function renderPalette() {
            const paletteDiv = document.getElementById('palette');
            paletteDiv.innerHTML = '';

            palettes[currentPalette].forEach((color, i) => {
                const div = document.createElement('div');
                div.className = 'palette-color' + (color === foregroundColor ? ' active' : '');
                div.style.background = color;
                div.onclick = (e) => {
                    if (e.button === 2 || e.ctrlKey) {
                        backgroundColor = color;
                        document.getElementById('backgroundPreview').style.background = color;
                    } else {
                        foregroundColor = color;
                        document.getElementById('foregroundPreview').style.background = color;
                        document.getElementById('colorPicker').value = color;
                        document.querySelectorAll('.palette-color').forEach(p => p.classList.remove('active'));
                        div.classList.add('active');
                    }
                };
                div.oncontextmenu = (e) => {
                    e.preventDefault();
                    backgroundColor = color;
                    document.getElementById('backgroundPreview').style.background = color;
                };
                paletteDiv.appendChild(div);
            });
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            saveState();
        }

        function flipHorizontal() {
            const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            ctx.save();
            ctx.translate(canvasWidth, 0);
            ctx.scale(-1, 1);
            ctx.putImageData(imageData, 0, 0);
            ctx.restore();

            // Redraw flipped
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvasWidth;
            tempCanvas.height = canvasHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.translate(canvasWidth, 0);
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(canvas, 0, 0);

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.drawImage(tempCanvas, 0, 0);
            saveState();
        }

        function flipVertical() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvasWidth;
            tempCanvas.height = canvasHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.translate(0, canvasHeight);
            tempCtx.scale(1, -1);
            tempCtx.drawImage(canvas, 0, 0);

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.drawImage(tempCanvas, 0, 0);
            saveState();
        }

        function rotate90() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvasHeight;
            tempCanvas.height = canvasWidth;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.translate(canvasHeight, 0);
            tempCtx.rotate(Math.PI / 2);
            tempCtx.drawImage(canvas, 0, 0);

            canvasWidth = tempCanvas.width;
            canvasHeight = tempCanvas.height;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            ctx.drawImage(tempCanvas, 0, 0);

            document.getElementById('canvasWidth').value = canvasWidth;
            document.getElementById('canvasHeight').value = canvasHeight;

            setZoom(zoom);
            saveState();
        }

        function exportPNG() {
            const link = document.createElement('a');
            link.download = `pixel-art-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function importImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    canvasWidth = Math.min(img.width, 256);
                    canvasHeight = Math.min(img.height, 256);
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

                    document.getElementById('canvasWidth').value = canvasWidth;
                    document.getElementById('canvasHeight').value = canvasHeight;

                    setZoom(zoom);
                    saveState();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Event listeners
        let previewState = null;

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const { x, y } = getPixelCoords(e);
            startX = x;
            startY = y;
            lastX = x;
            lastY = y;

            const color = e.button === 2 ? backgroundColor : foregroundColor;

            switch (currentTool) {
                case 'pencil':
                    drawPixel(x, y, color);
                    break;
                case 'eraser':
                    erasePixel(x, y);
                    break;
                case 'fill':
                    floodFill(x, y, color);
                    saveState();
                    break;
                case 'eyedropper':
                    const pickedColor = getPixelColor(x, y);
                    if (pickedColor) {
                        foregroundColor = pickedColor;
                        document.getElementById('foregroundPreview').style.background = pickedColor;
                        document.getElementById('colorPicker').value = pickedColor;
                    }
                    break;
                case 'line':
                case 'rect':
                case 'circle':
                    previewState = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
                    break;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const { x, y } = getPixelCoords(e);
            document.getElementById('coordinates').textContent = `X: ${x}, Y: ${y}`;

            if (!isDrawing) return;

            const color = e.buttons === 2 ? backgroundColor : foregroundColor;

            switch (currentTool) {
                case 'pencil':
                    drawLine(lastX, lastY, x, y, color);
                    break;
                case 'eraser':
                    // Draw erase line
                    const dx = Math.abs(x - lastX);
                    const dy = Math.abs(y - lastY);
                    const sx = lastX < x ? 1 : -1;
                    const sy = lastY < y ? 1 : -1;
                    let err = dx - dy;
                    let cx = lastX, cy = lastY;

                    while (true) {
                        erasePixel(cx, cy);
                        if (cx === x && cy === y) break;
                        const e2 = 2 * err;
                        if (e2 > -dy) { err -= dy; cx += sx; }
                        if (e2 < dx) { err += dx; cy += sy; }
                    }
                    break;
                case 'line':
                    if (previewState) {
                        ctx.putImageData(previewState, 0, 0);
                        drawLine(startX, startY, x, y, color);
                    }
                    break;
                case 'rect':
                    if (previewState) {
                        ctx.putImageData(previewState, 0, 0);
                        drawRect(startX, startY, x, y, color, e.shiftKey);
                    }
                    break;
                case 'circle':
                    if (previewState) {
                        ctx.putImageData(previewState, 0, 0);
                        drawCircle(startX, startY, x, y, color);
                    }
                    break;
            }

            lastX = x;
            lastY = y;
        });

        canvas.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                previewState = null;
                if (currentTool !== 'fill' && currentTool !== 'eyedropper') {
                    saveState();
                }
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDrawing) {
                isDrawing = false;
                previewState = null;
                saveState();
            }
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Tool buttons
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
            });
        });

        document.getElementById('colorPicker').addEventListener('input', (e) => {
            foregroundColor = e.target.value;
            document.getElementById('foregroundPreview').style.background = foregroundColor;
        });

        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('sizeDisplay').textContent = brushSize + 'px';
        });

        document.getElementById('paletteSelect').addEventListener('change', (e) => {
            currentPalette = e.target.value;
            renderPalette();
        });

        document.getElementById('toggleGrid').addEventListener('click', () => {
            showGrid = !showGrid;
            document.getElementById('toggleGrid').classList.toggle('active', showGrid);
            drawGrid();
        });

        document.getElementById('zoomIn').addEventListener('click', () => setZoom(zoom + 2));
        document.getElementById('zoomOut').addEventListener('click', () => setZoom(zoom - 2));

        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);
        document.getElementById('clearBtn').addEventListener('click', clearCanvas);
        document.getElementById('flipH').addEventListener('click', flipHorizontal);
        document.getElementById('flipV').addEventListener('click', flipVertical);
        document.getElementById('rotate').addEventListener('click', rotate90);
        document.getElementById('exportBtn').addEventListener('click', exportPNG);

        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('importInput').click();
        });

        document.getElementById('importInput').addEventListener('change', (e) => {
            if (e.target.files[0]) {
                importImage(e.target.files[0]);
            }
        });

        document.getElementById('resizeCanvas').addEventListener('click', () => {
            const newWidth = parseInt(document.getElementById('canvasWidth').value);
            const newHeight = parseInt(document.getElementById('canvasHeight').value);

            if (newWidth > 0 && newWidth <= 256 && newHeight > 0 && newHeight <= 256) {
                const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
                canvasWidth = newWidth;
                canvasHeight = newHeight;
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                ctx.putImageData(imageData, 0, 0);
                setZoom(zoom);
                saveState();
            }
        });

        document.getElementById('canvasPreset').addEventListener('change', (e) => {
            if (e.target.value) {
                const size = parseInt(e.target.value);
                document.getElementById('canvasWidth').value = size;
                document.getElementById('canvasHeight').value = size;
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            const shortcuts = {
                'p': 'pencil',
                'e': 'eraser',
                'f': 'fill',
                'l': 'line',
                'r': 'rect',
                'c': 'circle',
                'i': 'eyedropper',
                'm': 'move'
            };

            if (shortcuts[e.key.toLowerCase()]) {
                document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                document.querySelector(`[data-tool="${shortcuts[e.key.toLowerCase()]}"]`).classList.add('active');
                currentTool = shortcuts[e.key.toLowerCase()];
            }

            if (e.key === 'g') {
                showGrid = !showGrid;
                document.getElementById('toggleGrid').classList.toggle('active', showGrid);
                drawGrid();
            }

            if (e.key === '+' || e.key === '=') setZoom(zoom + 2);
            if (e.key === '-') setZoom(zoom - 2);

            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });

        // Initialize
        renderPalette();
        initCanvas();
        document.getElementById('toggleGrid').classList.add('active');
    </script>
</body>
</html>
