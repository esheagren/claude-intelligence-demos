<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cellular Automata</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 280px;
            background: rgba(20, 20, 30, 0.9);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
        }

        h1 {
            font-size: 1.4em;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 20px;
        }

        .section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section h3 {
            font-size: 0.85em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
            flex: 1;
            min-width: 80px;
        }

        .btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
        }

        .btn.active {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00ff88;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 0.8em;
            color: #aaa;
            margin-bottom: 6px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }

        .value-display {
            font-size: 0.75em;
            color: #00ff88;
            float: right;
        }

        .rule-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .rule-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75em;
            text-align: center;
            transition: all 0.2s;
        }

        .rule-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
        }

        .rule-btn.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ff88;
        }

        .stat-label {
            font-size: 0.7em;
            color: #888;
            text-transform: uppercase;
        }

        .main-area {
            flex: 1;
            position: relative;
        }

        #canvas {
            width: 100%;
            height: 100%;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 0.8em;
        }

        .info-panel h4 {
            color: #00ff88;
            margin-bottom: 8px;
        }

        .info-panel p {
            color: #aaa;
        }

        .help-text {
            font-size: 0.75em;
            color: #666;
            line-height: 1.5;
            margin-top: 15px;
        }

        .color-scheme {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.active {
            border-color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>3D Cellular Automata</h1>
            <p class="subtitle">Game of Life in Three Dimensions</p>

            <div class="section">
                <h3>Simulation</h3>
                <div class="btn-group">
                    <button class="btn" id="playBtn">▶ Play</button>
                    <button class="btn" id="stepBtn">Step</button>
                    <button class="btn" id="resetBtn">Reset</button>
                </div>
            </div>

            <div class="section">
                <h3>Rules</h3>
                <div class="rule-grid">
                    <button class="rule-btn active" data-rule="445m">4/4/5/M</button>
                    <button class="rule-btn" data-rule="567">5/6/7</button>
                    <button class="rule-btn" data-rule="clouds">Clouds</button>
                    <button class="rule-btn" data-rule="crystal">Crystal</button>
                    <button class="rule-btn" data-rule="amoeba">Amoeba</button>
                    <button class="rule-btn" data-rule="builder">Builder</button>
                </div>
                <div style="margin-top: 15px; font-size: 0.8em; color: #888;">
                    <div id="ruleDescription">Birth: 4 | Survival: 4 | States: 5</div>
                </div>
            </div>

            <div class="section">
                <h3>Pattern</h3>
                <div class="rule-grid">
                    <button class="rule-btn active" data-pattern="random">Random</button>
                    <button class="rule-btn" data-pattern="center">Center</button>
                    <button class="rule-btn" data-pattern="sphere">Sphere</button>
                    <button class="rule-btn" data-pattern="cube">Cube</button>
                    <button class="rule-btn" data-pattern="cross">Cross</button>
                    <button class="rule-btn" data-pattern="noise">Noise</button>
                </div>
            </div>

            <div class="section">
                <h3>Settings</h3>
                <div class="control-group">
                    <label>Grid Size <span class="value-display" id="sizeVal">24</span></label>
                    <input type="range" id="gridSize" min="12" max="40" value="24">
                </div>
                <div class="control-group">
                    <label>Density <span class="value-display" id="densityVal">15%</span></label>
                    <input type="range" id="density" min="5" max="40" value="15">
                </div>
                <div class="control-group">
                    <label>Speed <span class="value-display" id="speedVal">5</span></label>
                    <input type="range" id="speed" min="1" max="20" value="5">
                </div>
                <div class="control-group">
                    <label>Rotation Speed <span class="value-display" id="rotVal">1.0</span></label>
                    <input type="range" id="rotation" min="0" max="30" value="10">
                </div>
            </div>

            <div class="section">
                <h3>Colors</h3>
                <div class="color-scheme">
                    <div class="color-option active" style="background: linear-gradient(135deg, #00ff88, #00d4ff);" data-scheme="cyber"></div>
                    <div class="color-option" style="background: linear-gradient(135deg, #ff6b6b, #feca57);" data-scheme="fire"></div>
                    <div class="color-option" style="background: linear-gradient(135deg, #a29bfe, #fd79a8);" data-scheme="vapor"></div>
                    <div class="color-option" style="background: linear-gradient(135deg, #74b9ff, #0984e3);" data-scheme="ocean"></div>
                    <div class="color-option" style="background: linear-gradient(135deg, #ffffff, #888888);" data-scheme="mono"></div>
                </div>
            </div>

            <div class="section">
                <h3>Statistics</h3>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="genStat">0</div>
                        <div class="stat-label">Generation</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="aliveStat">0</div>
                        <div class="stat-label">Alive Cells</div>
                    </div>
                </div>
            </div>

            <div class="help-text">
                <strong>Controls:</strong><br>
                Drag to rotate view<br>
                Scroll to zoom in/out
            </div>
        </div>

        <div class="main-area">
            <canvas id="canvas"></canvas>
            <div class="info-panel">
                <h4>3D Cellular Automata</h4>
                <p>Conway's Game of Life extended to three dimensions</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let gridSize = 24;
        let grid = [];
        let nextGrid = [];
        let generation = 0;
        let isPlaying = false;
        let animationId;
        let lastUpdate = 0;
        let updateInterval = 200;

        // Camera
        let rotationX = 0.5;
        let rotationY = 0.3;
        let zoom = 1.0;
        let autoRotate = true;
        let rotationSpeed = 0.003;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Rules (Birth, Survival, States)
        const rules = {
            '445m': { birth: [4], survival: [4], states: 5, name: '4/4/5/M' },
            '567': { birth: [5], survival: [6, 7], states: 2, name: '5/6/7' },
            'clouds': { birth: [13, 14, 17, 18, 19], survival: [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26], states: 2, name: 'Clouds' },
            'crystal': { birth: [5, 6, 7], survival: [6, 7, 8], states: 2, name: 'Crystal' },
            'amoeba': { birth: [9, 10, 11, 12, 13, 14, 15, 16], survival: [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], states: 3, name: 'Amoeba' },
            'builder': { birth: [4, 6, 8, 9], survival: [3, 4, 5, 6, 7, 8, 9], states: 2, name: 'Builder' }
        };

        let currentRule = rules['445m'];

        // Color schemes
        const colorSchemes = {
            cyber: [
                [0, 0, 0],
                [0, 255, 136],
                [0, 212, 255],
                [0, 180, 255],
                [0, 150, 200]
            ],
            fire: [
                [0, 0, 0],
                [255, 107, 107],
                [254, 202, 87],
                [255, 165, 2],
                [255, 100, 0]
            ],
            vapor: [
                [0, 0, 0],
                [162, 155, 254],
                [253, 121, 168],
                [255, 234, 167],
                [129, 236, 236]
            ],
            ocean: [
                [0, 0, 0],
                [116, 185, 255],
                [9, 132, 227],
                [0, 206, 201],
                [0, 150, 150]
            ],
            mono: [
                [0, 0, 0],
                [255, 255, 255],
                [200, 200, 200],
                [150, 150, 150],
                [100, 100, 100]
            ]
        };

        let currentScheme = colorSchemes.cyber;

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        function initGrid() {
            grid = [];
            nextGrid = [];
            for (let x = 0; x < gridSize; x++) {
                grid[x] = [];
                nextGrid[x] = [];
                for (let y = 0; y < gridSize; y++) {
                    grid[x][y] = [];
                    nextGrid[x][y] = [];
                    for (let z = 0; z < gridSize; z++) {
                        grid[x][y][z] = 0;
                        nextGrid[x][y][z] = 0;
                    }
                }
            }
            generation = 0;
        }

        function setPattern(pattern) {
            initGrid();
            const center = Math.floor(gridSize / 2);
            const density = parseInt(document.getElementById('density').value) / 100;

            switch (pattern) {
                case 'random':
                    for (let x = 0; x < gridSize; x++) {
                        for (let y = 0; y < gridSize; y++) {
                            for (let z = 0; z < gridSize; z++) {
                                if (Math.random() < density) {
                                    grid[x][y][z] = currentRule.states - 1;
                                }
                            }
                        }
                    }
                    break;

                case 'center':
                    const radius = 3;
                    for (let x = center - radius; x <= center + radius; x++) {
                        for (let y = center - radius; y <= center + radius; y++) {
                            for (let z = center - radius; z <= center + radius; z++) {
                                if (Math.random() < 0.5) {
                                    grid[x][y][z] = currentRule.states - 1;
                                }
                            }
                        }
                    }
                    break;

                case 'sphere':
                    const sphereRadius = gridSize / 4;
                    for (let x = 0; x < gridSize; x++) {
                        for (let y = 0; y < gridSize; y++) {
                            for (let z = 0; z < gridSize; z++) {
                                const dx = x - center;
                                const dy = y - center;
                                const dz = z - center;
                                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                                if (dist < sphereRadius && Math.random() < density * 2) {
                                    grid[x][y][z] = currentRule.states - 1;
                                }
                            }
                        }
                    }
                    break;

                case 'cube':
                    const cubeSize = Math.floor(gridSize / 3);
                    const offset = Math.floor((gridSize - cubeSize) / 2);
                    for (let x = offset; x < offset + cubeSize; x++) {
                        for (let y = offset; y < offset + cubeSize; y++) {
                            for (let z = offset; z < offset + cubeSize; z++) {
                                if (Math.random() < density * 2) {
                                    grid[x][y][z] = currentRule.states - 1;
                                }
                            }
                        }
                    }
                    break;

                case 'cross':
                    const crossWidth = 2;
                    for (let i = 0; i < gridSize; i++) {
                        for (let j = center - crossWidth; j <= center + crossWidth; j++) {
                            for (let k = center - crossWidth; k <= center + crossWidth; k++) {
                                grid[i][j][k] = currentRule.states - 1;
                                grid[j][i][k] = currentRule.states - 1;
                                grid[j][k][i] = currentRule.states - 1;
                            }
                        }
                    }
                    break;

                case 'noise':
                    for (let x = 0; x < gridSize; x++) {
                        for (let y = 0; y < gridSize; y++) {
                            for (let z = 0; z < gridSize; z++) {
                                const noise = Math.sin(x * 0.5) * Math.cos(y * 0.5) * Math.sin(z * 0.5);
                                if (noise > 0.3 && Math.random() < density * 2) {
                                    grid[x][y][z] = currentRule.states - 1;
                                }
                            }
                        }
                    }
                    break;
            }
        }

        function countNeighbors(x, y, z) {
            let count = 0;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dy === 0 && dz === 0) continue;

                        const nx = x + dx;
                        const ny = y + dy;
                        const nz = z + dz;

                        if (nx >= 0 && nx < gridSize &&
                            ny >= 0 && ny < gridSize &&
                            nz >= 0 && nz < gridSize) {
                            if (grid[nx][ny][nz] === currentRule.states - 1) {
                                count++;
                            }
                        }
                    }
                }
            }
            return count;
        }

        function step() {
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        const neighbors = countNeighbors(x, y, z);
                        const currentState = grid[x][y][z];

                        if (currentState === 0) {
                            // Dead cell
                            if (currentRule.birth.includes(neighbors)) {
                                nextGrid[x][y][z] = currentRule.states - 1;
                            } else {
                                nextGrid[x][y][z] = 0;
                            }
                        } else if (currentState === currentRule.states - 1) {
                            // Fully alive cell
                            if (currentRule.survival.includes(neighbors)) {
                                nextGrid[x][y][z] = currentRule.states - 1;
                            } else {
                                nextGrid[x][y][z] = currentState - 1;
                            }
                        } else {
                            // Dying cell
                            nextGrid[x][y][z] = currentState - 1;
                        }
                    }
                }
            }

            // Swap grids
            const temp = grid;
            grid = nextGrid;
            nextGrid = temp;

            generation++;
            updateStats();
        }

        function updateStats() {
            let alive = 0;
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        if (grid[x][y][z] > 0) alive++;
                    }
                }
            }
            document.getElementById('genStat').textContent = generation;
            document.getElementById('aliveStat').textContent = alive;
        }

        function project(x, y, z) {
            // Center the grid
            const cx = x - gridSize / 2;
            const cy = y - gridSize / 2;
            const cz = z - gridSize / 2;

            // Rotate around Y axis
            const cosY = Math.cos(rotationY);
            const sinY = Math.sin(rotationY);
            const x1 = cx * cosY - cz * sinY;
            const z1 = cx * sinY + cz * cosY;

            // Rotate around X axis
            const cosX = Math.cos(rotationX);
            const sinX = Math.sin(rotationX);
            const y1 = cy * cosX - z1 * sinX;
            const z2 = cy * sinX + z1 * cosX;

            // Perspective projection
            const scale = 300 * zoom / (z2 + gridSize + 10);
            const screenX = canvas.width / 2 + x1 * scale;
            const screenY = canvas.height / 2 + y1 * scale;

            return { x: screenX, y: screenY, z: z2, scale };
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Collect all cells to draw
            const cells = [];

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        const state = grid[x][y][z];
                        if (state > 0) {
                            const proj = project(x, y, z);
                            cells.push({ x, y, z, state, proj });
                        }
                    }
                }
            }

            // Sort by z for proper depth rendering
            cells.sort((a, b) => a.proj.z - b.proj.z);

            // Draw cells
            cells.forEach(cell => {
                const { proj, state } = cell;
                const colorIndex = Math.min(state, currentScheme.length - 1);
                const color = currentScheme[colorIndex];
                const size = Math.max(2, proj.scale * 0.4);
                const alpha = 0.3 + (state / currentRule.states) * 0.7;

                ctx.beginPath();
                ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
                ctx.fill();

                // Glow effect for fully alive cells
                if (state === currentRule.states - 1) {
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size * 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.2)`;
                    ctx.fill();
                }
            });

            // Draw grid boundary (optional wireframe)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;

            // Bottom face
            const corners = [
                [0, 0, 0], [gridSize, 0, 0], [gridSize, 0, gridSize], [0, 0, gridSize],
                [0, gridSize, 0], [gridSize, gridSize, 0], [gridSize, gridSize, gridSize], [0, gridSize, gridSize]
            ];

            const projCorners = corners.map(c => project(c[0], c[1], c[2]));

            // Draw edges
            const edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],
                [4, 5], [5, 6], [6, 7], [7, 4],
                [0, 4], [1, 5], [2, 6], [3, 7]
            ];

            edges.forEach(edge => {
                const p1 = projCorners[edge[0]];
                const p2 = projCorners[edge[1]];
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });
        }

        function animate(timestamp) {
            if (autoRotate) {
                rotationY += rotationSpeed;
            }

            if (isPlaying && timestamp - lastUpdate > updateInterval) {
                step();
                lastUpdate = timestamp;
            }

            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            step();
            draw();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            const activePattern = document.querySelector('.rule-btn[data-pattern].active');
            setPattern(activePattern ? activePattern.dataset.pattern : 'random');
            draw();
        });

        document.querySelectorAll('.rule-btn[data-rule]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.rule-btn[data-rule]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentRule = rules[btn.dataset.rule];
                document.getElementById('ruleDescription').textContent =
                    `Birth: ${currentRule.birth.join(',')} | Survival: ${currentRule.survival.join(',')} | States: ${currentRule.states}`;
            });
        });

        document.querySelectorAll('.rule-btn[data-pattern]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.rule-btn[data-pattern]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                setPattern(btn.dataset.pattern);
                draw();
            });
        });

        document.getElementById('gridSize').addEventListener('input', (e) => {
            gridSize = parseInt(e.target.value);
            document.getElementById('sizeVal').textContent = gridSize;
            initGrid();
            const activePattern = document.querySelector('.rule-btn[data-pattern].active');
            setPattern(activePattern ? activePattern.dataset.pattern : 'random');
        });

        document.getElementById('density').addEventListener('input', (e) => {
            document.getElementById('densityVal').textContent = e.target.value + '%';
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            updateInterval = 400 - (e.target.value * 18);
            document.getElementById('speedVal').textContent = e.target.value;
        });

        document.getElementById('rotation').addEventListener('input', (e) => {
            rotationSpeed = e.target.value / 1000;
            document.getElementById('rotVal').textContent = (e.target.value / 10).toFixed(1);
        });

        document.querySelectorAll('.color-option').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.color-option').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentScheme = colorSchemes[btn.dataset.scheme];
            });
        });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            autoRotate = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                rotationY += dx * 0.01;
                rotationX += dy * 0.01;
                rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= 1 - e.deltaY * 0.001;
            zoom = Math.max(0.5, Math.min(3, zoom));
        });

        window.addEventListener('resize', resizeCanvas);

        // Initialize
        resizeCanvas();
        initGrid();
        setPattern('random');
        updateStats();
        animate(0);
    </script>
</body>
</html>
