<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Beauty: Infinite Explorations</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #000;
            color: #e0e0e0;
            font-family: 'Georgia', serif;
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: crosshair;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            padding: 30px;
        }

        h1 {
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 4px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            margin-bottom: 8px;
        }

        .subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            letter-spacing: 2px;
        }

        .info-panel {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 400px;
            pointer-events: auto;
        }

        .info-panel h3 {
            font-size: 16px;
            color: #fff;
            margin-bottom: 10px;
            font-weight: 400;
        }

        .info-panel p {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .formula {
            font-family: 'Courier New', monospace;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 4px;
            font-size: 11px;
            color: #7dd3fc;
            margin: 10px 0;
        }

        .controls {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            font-size: 12px;
            transition: all 0.3s;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn.active {
            background: rgba(100, 180, 255, 0.3);
            border-color: rgba(100, 180, 255, 0.5);
        }

        .stats {
            position: absolute;
            bottom: 30px;
            right: 30px;
            text-align: right;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
        }

        .meditation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s;
        }

        .meditation.visible {
            opacity: 1;
        }

        .meditation-text {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
            max-width: 500px;
            line-height: 1.8;
        }

        .meditation-author {
            margin-top: 20px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="overlay">
        <h1>MATHEMATICAL BEAUTY</h1>
        <div class="subtitle">Infinite Explorations in Number and Form</div>
    </div>

    <div class="controls">
        <button class="btn active" data-mode="mandelbrot">Mandelbrot Set</button>
        <button class="btn" data-mode="julia">Julia Sets</button>
        <button class="btn" data-mode="newton">Newton Fractals</button>
        <button class="btn" data-mode="lorenz">Strange Attractors</button>
        <button class="btn" data-mode="golden">Golden Spirals</button>
        <button class="btn" data-mode="prime">Prime Spirals</button>
        <button class="btn" data-mode="wave">Wave Functions</button>
        <button class="btn" data-mode="cellular">Cellular Automata</button>
    </div>

    <div class="info-panel" id="info-panel">
        <h3 id="info-title">The Mandelbrot Set</h3>
        <p id="info-description">
            The boundary between the finite and infinite, this set reveals complexity from the simplest of rules.
            Each point represents a journey through the complex plane.
        </p>
        <div class="formula" id="info-formula">z(n+1) = z(n)² + c</div>
        <p id="info-philosophy">
            In its infinite detail lies a profound truth: complexity need not arise from complexity.
            The universe whispers its secrets through iteration.
        </p>
    </div>

    <div class="stats">
        <div id="zoom">Zoom: 1x</div>
        <div id="iterations">Iterations: 0</div>
        <div id="center">Center: (0, 0)</div>
    </div>

    <div class="meditation" id="meditation">
        <div class="meditation-text" id="meditation-text"></div>
        <div class="meditation-author" id="meditation-author"></div>
    </div>

    <script>
        // ============================================
        // MATHEMATICAL BEAUTY EXPLORER
        // ============================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let currentMode = 'mandelbrot';
        let animationId;
        let time = 0;

        // Fractal state
        let centerX = -0.5, centerY = 0;
        let zoom = 1;
        let maxIterations = 100;

        // Julia set parameter
        let juliaC = { r: -0.7, i: 0.27015 };

        // Attractor state
        let attractorPoints = [];

        // Animation state
        let isAnimating = true;

        const meditations = [
            { text: "Mathematics is the language with which God has written the universe.", author: "Galileo Galilei" },
            { text: "The essence of mathematics lies in its freedom.", author: "Georg Cantor" },
            { text: "Mathematics reveals its secrets only to those who approach it with pure love.", author: "Archimedes" },
            { text: "In mathematics the art of proposing a question must be held of higher value than solving it.", author: "Georg Cantor" },
            { text: "The mathematician does not study pure mathematics because it is useful; he studies it because he delights in it.", author: "Henri Poincaré" },
            { text: "Mathematics is not about numbers, equations, computations, or algorithms: it is about understanding.", author: "William Thurston" },
            { text: "The infinite! No other question has ever moved so profoundly the spirit of man.", author: "David Hilbert" },
            { text: "Pure mathematics is, in its way, the poetry of logical ideas.", author: "Albert Einstein" }
        ];

        const modes = {
            mandelbrot: {
                title: "The Mandelbrot Set",
                description: "The boundary between the finite and infinite, this set reveals complexity from the simplest of rules.",
                formula: "z(n+1) = z(n)² + c",
                philosophy: "In its infinite detail lies a profound truth: complexity need not arise from complexity."
            },
            julia: {
                title: "Julia Sets",
                description: "Companion sets to the Mandelbrot, each point in the Mandelbrot set births its own unique Julia set.",
                formula: "z(n+1) = z(n)² + c, where c is constant",
                philosophy: "Every mathematical truth casts infinite shadows, each as beautiful as its source."
            },
            newton: {
                title: "Newton's Method Fractals",
                description: "The dance of convergence revealed: where different roots attract creates fractal boundaries.",
                formula: "z(n+1) = z(n) - f(z)/f'(z), for f(z) = z³ - 1",
                philosophy: "Even in finding simple roots, nature cannot resist painting with infinity."
            },
            lorenz: {
                title: "Strange Attractors",
                description: "Chaos theory made visible: deterministic yet unpredictable, the butterfly effect incarnate.",
                formula: "dx/dt = σ(y-x), dy/dt = x(ρ-z)-y, dz/dt = xy-βz",
                philosophy: "Order within chaos, chaos within order—the universe dances between states."
            },
            golden: {
                title: "Golden Spirals",
                description: "The divine proportion, φ = 1.618..., manifests in spirals that pervade nature.",
                formula: "φ = (1 + √5) / 2 ≈ 1.618033988749...",
                philosophy: "From sunflowers to galaxies, this ratio whispers of a deeper harmony."
            },
            prime: {
                title: "Ulam's Prime Spiral",
                description: "When integers spiral outward and primes are marked, mysterious patterns emerge.",
                formula: "Prime numbers arranged in a square spiral",
                philosophy: "The primes, atoms of arithmetic, align themselves along invisible threads."
            },
            wave: {
                title: "Quantum Wave Functions",
                description: "Probability amplitudes of quantum mechanics, where particles are waves of possibility.",
                formula: "iℏ ∂Ψ/∂t = ĤΨ (Schrödinger's equation)",
                philosophy: "Reality itself, at its deepest level, is a superposition of all possibilities."
            },
            cellular: {
                title: "Cellular Automata",
                description: "Simple rules, applied locally, generate complexity that mirrors life itself.",
                formula: "Rule 110: proven to be Turing complete",
                philosophy: "Computation is woven into the fabric of existence."
            }
        };

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        // ============================================
        // COLOR PALETTES
        // ============================================

        function getColor(t, palette = 0) {
            t = Math.max(0, Math.min(1, t));

            const palettes = [
                // Deep ocean
                (t) => {
                    const r = Math.sin(t * Math.PI) * 50;
                    const g = Math.sin(t * Math.PI * 0.5 + 0.5) * 100 + 50;
                    const b = Math.sin(t * Math.PI * 0.3 + 0.2) * 155 + 100;
                    return `rgb(${r}, ${g}, ${b})`;
                },
                // Fire
                (t) => {
                    const r = Math.min(255, t * 500);
                    const g = Math.min(255, Math.max(0, (t - 0.3) * 400));
                    const b = Math.min(255, Math.max(0, (t - 0.7) * 500));
                    return `rgb(${r}, ${g}, ${b})`;
                },
                // Aurora
                (t) => {
                    const r = Math.sin(t * Math.PI * 2) * 80 + 80;
                    const g = Math.sin(t * Math.PI * 2 + 2) * 100 + 150;
                    const b = Math.sin(t * Math.PI * 2 + 4) * 80 + 150;
                    return `rgb(${r}, ${g}, ${b})`;
                },
                // Cosmic
                (t) => {
                    const r = Math.sin(t * Math.PI * 3) * 100 + 100;
                    const g = Math.sin(t * Math.PI * 2 + 1) * 50 + 50;
                    const b = Math.sin(t * Math.PI * 2.5 + 0.5) * 100 + 150;
                    return `rgb(${r}, ${g}, ${b})`;
                }
            ];

            return palettes[palette % palettes.length](t);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
        }

        // ============================================
        // MANDELBROT SET
        // ============================================

        function renderMandelbrot() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            const scale = 3.5 / (zoom * Math.min(width, height));
            const offsetX = centerX - width * scale / 2;
            const offsetY = centerY - height * scale / 2;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x0 = px * scale + offsetX;
                    const y0 = py * scale + offsetY;

                    let x = 0, y = 0;
                    let iteration = 0;

                    while (x * x + y * y <= 4 && iteration < maxIterations) {
                        const xTemp = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xTemp;
                        iteration++;
                    }

                    const idx = (py * width + px) * 4;

                    if (iteration === maxIterations) {
                        data[idx] = data[idx + 1] = data[idx + 2] = 0;
                    } else {
                        // Smooth coloring
                        const smoothed = iteration + 1 - Math.log2(Math.log2(x * x + y * y));
                        const t = smoothed / maxIterations;
                        const color = hslToRgb((t * 0.7 + time * 0.0001) % 1, 0.8, 0.5);
                        data[idx] = color.r;
                        data[idx + 1] = color.g;
                        data[idx + 2] = color.b;
                    }
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // ============================================
        // JULIA SET
        // ============================================

        function renderJulia() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            // Animate Julia parameter
            const angle = time * 0.0005;
            const radius = 0.7885;
            juliaC.r = Math.cos(angle) * radius;
            juliaC.i = Math.sin(angle) * radius;

            const scale = 3 / (zoom * Math.min(width, height));
            const offsetX = centerX - width * scale / 2;
            const offsetY = centerY - height * scale / 2;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    let x = px * scale + offsetX;
                    let y = py * scale + offsetY;
                    let iteration = 0;

                    while (x * x + y * y <= 4 && iteration < maxIterations) {
                        const xTemp = x * x - y * y + juliaC.r;
                        y = 2 * x * y + juliaC.i;
                        x = xTemp;
                        iteration++;
                    }

                    const idx = (py * width + px) * 4;

                    if (iteration === maxIterations) {
                        data[idx] = data[idx + 1] = data[idx + 2] = 0;
                    } else {
                        const t = iteration / maxIterations;
                        const color = hslToRgb((t * 0.8 + 0.5) % 1, 0.9, 0.4 + t * 0.3);
                        data[idx] = color.r;
                        data[idx + 1] = color.g;
                        data[idx + 2] = color.b;
                    }
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // ============================================
        // NEWTON FRACTAL
        // ============================================

        function renderNewton() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            const scale = 4 / (zoom * Math.min(width, height));
            const offsetX = centerX - width * scale / 2;
            const offsetY = centerY - height * scale / 2;

            // Roots of z³ - 1 = 0
            const roots = [
                { r: 1, i: 0 },
                { r: -0.5, i: Math.sqrt(3) / 2 },
                { r: -0.5, i: -Math.sqrt(3) / 2 }
            ];

            const rootColors = [
                { r: 255, g: 100, b: 100 },
                { r: 100, g: 255, b: 100 },
                { r: 100, g: 100, b: 255 }
            ];

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    let zr = px * scale + offsetX;
                    let zi = py * scale + offsetY;
                    let iteration = 0;
                    let rootIndex = -1;

                    while (iteration < maxIterations) {
                        // f(z) = z³ - 1
                        // f'(z) = 3z²
                        // Newton: z = z - f(z)/f'(z) = z - (z³-1)/(3z²)

                        const zr2 = zr * zr;
                        const zi2 = zi * zi;
                        const zr3 = zr * (zr2 - 3 * zi2);
                        const zi3 = zi * (3 * zr2 - zi2);

                        // f(z) = z³ - 1
                        const fr = zr3 - 1;
                        const fi = zi3;

                        // f'(z) = 3z²
                        const denom = 3 * (zr2 + zi2);
                        if (denom === 0) break;

                        // z - f(z)/f'(z)
                        // (a+bi)/(c+di) = (ac+bd)/(c²+d²) + i(bc-ad)/(c²+d²)
                        const dr = 3 * (zr2 - zi2);
                        const di = 6 * zr * zi;
                        const dMag = dr * dr + di * di;

                        if (dMag === 0) break;

                        const qr = (fr * dr + fi * di) / dMag;
                        const qi = (fi * dr - fr * di) / dMag;

                        zr -= qr;
                        zi -= qi;

                        // Check convergence to roots
                        for (let r = 0; r < roots.length; r++) {
                            const dist = Math.sqrt((zr - roots[r].r) ** 2 + (zi - roots[r].i) ** 2);
                            if (dist < 0.0001) {
                                rootIndex = r;
                                break;
                            }
                        }

                        if (rootIndex >= 0) break;
                        iteration++;
                    }

                    const idx = (py * width + px) * 4;

                    if (rootIndex >= 0) {
                        const brightness = 1 - iteration / maxIterations;
                        data[idx] = rootColors[rootIndex].r * brightness;
                        data[idx + 1] = rootColors[rootIndex].g * brightness;
                        data[idx + 2] = rootColors[rootIndex].b * brightness;
                    } else {
                        data[idx] = data[idx + 1] = data[idx + 2] = 0;
                    }
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // ============================================
        // LORENZ ATTRACTOR
        // ============================================

        function initLorenz() {
            attractorPoints = [];
            let x = 0.1, y = 0, z = 0;
            const sigma = 10, rho = 28, beta = 8/3;
            const dt = 0.005;

            for (let i = 0; i < 50000; i++) {
                const dx = sigma * (y - x);
                const dy = x * (rho - z) - y;
                const dz = x * y - beta * z;

                x += dx * dt;
                y += dy * dt;
                z += dz * dt;

                attractorPoints.push({ x, y, z });
            }
        }

        function renderLorenz() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, width, height);

            if (attractorPoints.length === 0) initLorenz();

            const rotationX = time * 0.0003;
            const rotationY = time * 0.0005;
            const scale = 10 * zoom;

            ctx.beginPath();

            for (let i = 0; i < attractorPoints.length; i++) {
                const p = attractorPoints[i];

                // Rotate
                const cosX = Math.cos(rotationX), sinX = Math.sin(rotationX);
                const cosY = Math.cos(rotationY), sinY = Math.sin(rotationY);

                const y1 = p.y * cosX - p.z * sinX;
                const z1 = p.y * sinX + p.z * cosX;
                const x1 = p.x * cosY + z1 * sinY;

                const screenX = width / 2 + x1 * scale;
                const screenY = height / 2 + y1 * scale;

                if (i === 0) {
                    ctx.moveTo(screenX, screenY);
                } else {
                    ctx.lineTo(screenX, screenY);
                }
            }

            const hue = (time * 0.02) % 360;
            ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.5)`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }

        // ============================================
        // GOLDEN SPIRAL
        // ============================================

        function renderGolden() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
            ctx.fillRect(0, 0, width, height);

            const phi = (1 + Math.sqrt(5)) / 2;
            const cx = width / 2;
            const cy = height / 2;

            // Draw Fibonacci spiral
            ctx.beginPath();
            const maxTheta = 8 * Math.PI + time * 0.001;

            for (let theta = 0; theta < maxTheta; theta += 0.01) {
                const r = Math.pow(phi, theta * 2 / Math.PI) * 2 * zoom;
                const x = cx + r * Math.cos(theta);
                const y = cy + r * Math.sin(theta);

                if (theta === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, '#ffd700');
            gradient.addColorStop(0.5, '#ff8c00');
            gradient.addColorStop(1, '#dc143c');

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw golden rectangles
            let size = 200 * zoom;
            let x = cx - size / 2;
            let y = cy - size / 2;

            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 1;

            for (let i = 0; i < 10; i++) {
                ctx.strokeRect(x, y, size, size);

                const newSize = size / phi;
                switch (i % 4) {
                    case 0: x += size - newSize; break;
                    case 1: y += size - newSize; break;
                    case 2: break;
                    case 3: break;
                }
                size = newSize;
            }

            // Golden ratio value
            ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
            ctx.font = '24px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('φ = ' + phi.toFixed(15), cx, cy + 250);
        }

        // ============================================
        // PRIME SPIRAL (ULAM SPIRAL)
        // ============================================

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        function renderPrimeSpiral() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const cx = width / 2;
            const cy = height / 2;
            const cellSize = 4 * zoom;
            const maxNum = Math.floor(Math.min(width, height) / cellSize) ** 2;

            // Generate spiral coordinates
            let x = 0, y = 0;
            let dx = 1, dy = 0;
            let segmentLength = 1;
            let segmentPassed = 0;
            let segmentCount = 0;

            for (let n = 1; n <= maxNum; n++) {
                if (isPrime(n)) {
                    const screenX = cx + x * cellSize;
                    const screenY = cy + y * cellSize;

                    // Color by position in spiral
                    const dist = Math.sqrt(x * x + y * y);
                    const hue = (dist * 5 + time * 0.01) % 360;

                    ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, cellSize * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Move in spiral
                x += dx;
                y += dy;
                segmentPassed++;

                if (segmentPassed === segmentLength) {
                    segmentPassed = 0;
                    segmentCount++;

                    // Turn left
                    const temp = dx;
                    dx = dy;
                    dy = -temp;

                    if (segmentCount === 2) {
                        segmentCount = 0;
                        segmentLength++;
                    }
                }
            }
        }

        // ============================================
        // WAVE FUNCTIONS (QUANTUM)
        // ============================================

        function renderWaveFunction() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            // Superposition of wave functions
            const k1 = 0.05, k2 = 0.03, k3 = 0.02;
            const omega = time * 0.002;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x = (px - width / 2) / zoom;
                    const y = (py - height / 2) / zoom;

                    // Wave packet superposition
                    const psi1 = Math.sin(k1 * x + omega) * Math.exp(-x * x / 10000);
                    const psi2 = Math.sin(k2 * y - omega * 0.7) * Math.exp(-y * y / 10000);
                    const psi3 = Math.sin(k3 * (x + y) + omega * 1.3);

                    // Probability density |ψ|²
                    const psiReal = psi1 + psi2 * 0.5 + psi3 * 0.3;
                    const psiImag = Math.cos(k1 * x + omega) * 0.5 + Math.cos(k2 * y - omega);
                    const prob = psiReal * psiReal + psiImag * psiImag;

                    const idx = (py * width + px) * 4;

                    // Interference pattern coloring
                    const intensity = Math.min(1, prob * 0.5);
                    const phase = Math.atan2(psiImag, psiReal);
                    const hue = ((phase + Math.PI) / (2 * Math.PI) + 0.6) % 1;

                    const color = hslToRgb(hue, 0.8, intensity * 0.7);
                    data[idx] = color.r;
                    data[idx + 1] = color.g;
                    data[idx + 2] = color.b;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // ============================================
        // CELLULAR AUTOMATA
        // ============================================

        let caGrid = [];
        let caGeneration = 0;

        function initCellularAutomata() {
            caGrid = [];
            const cols = Math.ceil(width / 4);

            // Random initial state
            const row = new Array(cols).fill(0);
            row[Math.floor(cols / 2)] = 1;
            caGrid.push(row);
            caGeneration = 0;
        }

        function renderCellularAutomata() {
            if (caGrid.length === 0) initCellularAutomata();

            const cellSize = 4;
            const cols = Math.ceil(width / cellSize);

            // Generate new rows if needed
            while (caGrid.length < height / cellSize) {
                const prevRow = caGrid[caGrid.length - 1];
                const newRow = new Array(cols).fill(0);

                // Rule 110
                for (let i = 0; i < cols; i++) {
                    const left = prevRow[(i - 1 + cols) % cols];
                    const center = prevRow[i];
                    const right = prevRow[(i + 1) % cols];
                    const pattern = (left << 2) | (center << 1) | right;

                    // Rule 110: 01101110 in binary = 110 in decimal
                    const rule = 110;
                    newRow[i] = (rule >> pattern) & 1;
                }

                caGrid.push(newRow);
                caGeneration++;
            }

            // Render
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            for (let y = 0; y < caGrid.length && y * cellSize < height; y++) {
                for (let x = 0; x < caGrid[y].length && x * cellSize < width; x++) {
                    if (caGrid[y][x]) {
                        const hue = (y * 0.5 + time * 0.01) % 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
                    }
                }
            }

            // Scroll
            if (caGrid.length > height / cellSize + 10) {
                caGrid.shift();
            }
        }

        // ============================================
        // MAIN RENDER LOOP
        // ============================================

        function render() {
            time++;

            switch (currentMode) {
                case 'mandelbrot': renderMandelbrot(); break;
                case 'julia': renderJulia(); break;
                case 'newton': renderNewton(); break;
                case 'lorenz': renderLorenz(); break;
                case 'golden': renderGolden(); break;
                case 'prime': renderPrimeSpiral(); break;
                case 'wave': renderWaveFunction(); break;
                case 'cellular': renderCellularAutomata(); break;
            }

            updateStats();

            if (isAnimating) {
                animationId = requestAnimationFrame(render);
            }
        }

        function updateStats() {
            document.getElementById('zoom').textContent = `Zoom: ${zoom.toFixed(2)}x`;
            document.getElementById('iterations').textContent = `Frame: ${time}`;
            document.getElementById('center').textContent = `Center: (${centerX.toFixed(4)}, ${centerY.toFixed(4)})`;
        }

        function updateInfo() {
            const info = modes[currentMode];
            document.getElementById('info-title').textContent = info.title;
            document.getElementById('info-description').textContent = info.description;
            document.getElementById('info-formula').textContent = info.formula;
            document.getElementById('info-philosophy').textContent = info.philosophy;
        }

        function showMeditation() {
            const med = meditations[Math.floor(Math.random() * meditations.length)];
            document.getElementById('meditation-text').textContent = `"${med.text}"`;
            document.getElementById('meditation-author').textContent = `— ${med.author}`;
            document.getElementById('meditation').classList.add('visible');

            setTimeout(() => {
                document.getElementById('meditation').classList.remove('visible');
            }, 8000);
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        function init() {
            resize();
            window.addEventListener('resize', () => {
                resize();
                if (currentMode === 'cellular') initCellularAutomata();
                if (currentMode === 'lorenz') initLorenz();
            });

            // Mode buttons
            document.querySelectorAll('.btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentMode = btn.dataset.mode;
                    updateInfo();

                    // Reset state for certain modes
                    centerX = currentMode === 'mandelbrot' ? -0.5 : 0;
                    centerY = 0;
                    zoom = 1;

                    if (currentMode === 'cellular') initCellularAutomata();
                    if (currentMode === 'lorenz') initLorenz();
                });
            });

            // Zoom with wheel
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                zoom *= zoomFactor;
                maxIterations = Math.min(500, Math.max(50, Math.floor(50 + Math.log2(zoom) * 20)));
            });

            // Pan with drag
            let isDragging = false;
            let lastX, lastY;

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const scale = 3.5 / (zoom * Math.min(width, height));
                centerX -= (e.clientX - lastX) * scale;
                centerY -= (e.clientY - lastY) * scale;

                lastX = e.clientX;
                lastY = e.clientY;
            });

            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);

            // Show meditation periodically
            setInterval(showMeditation, 60000);
            setTimeout(showMeditation, 10000);

            updateInfo();
            render();
        }

        init();
    </script>
</body>
</html>
