<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electric Field Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .canvas-area {
            flex: 1;
            position: relative;
        }

        #fieldCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .header-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
        }

        h1 {
            font-size: 2em;
            background: linear-gradient(135deg, #ffd700, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #888;
            font-size: 0.95em;
        }

        .controls-panel {
            width: 300px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
        }

        .control-group h3 {
            color: #ffd700;
            margin-bottom: 12px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            margin-bottom: 10px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-row label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
        }

        .control-row label span {
            color: #ffd700;
        }

        input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd700, #ff6b6b);
            cursor: pointer;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-row input {
            width: 16px;
            height: 16px;
            accent-color: #ffd700;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .mode-btn {
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
        }

        .mode-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #ffd700, #ff6b6b);
            color: #111;
        }

        .charge-btn {
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.2s;
        }

        .charge-btn.positive {
            background: linear-gradient(135deg, #ff4444, #ff6b6b);
            color: white;
        }

        .charge-btn.negative {
            background: linear-gradient(135deg, #4444ff, #6b6bff);
            color: white;
        }

        .charge-btn.active {
            box-shadow: 0 0 0 3px #fff;
        }

        .button-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn {
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
        }

        .btn.primary {
            background: linear-gradient(135deg, #ffd700, #ff6b6b);
            color: #111;
            font-weight: bold;
        }

        .btn.secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.1em;
            color: #ffd700;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.7em;
            color: #888;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .preset-btn {
            padding: 8px;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: rgba(255, 215, 0, 0.3);
        }

        .info-box {
            background: rgba(255, 215, 0, 0.1);
            border-left: 3px solid #ffd700;
            padding: 10px;
            border-radius: 0 8px 8px 0;
            font-size: 0.8em;
            line-height: 1.5;
        }

        .mouse-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85em;
        }

        .mouse-info span {
            color: #ffd700;
        }

        .charge-list {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 8px;
        }

        .charge-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            font-size: 0.8em;
        }

        .charge-item.positive {
            background: rgba(255, 68, 68, 0.2);
        }

        .charge-item.negative {
            background: rgba(68, 68, 255, 0.2);
        }

        .charge-item button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-area">
            <canvas id="fieldCanvas"></canvas>
            <div class="header-overlay">
                <h1>Electric Field</h1>
                <p class="subtitle">Electrostatics visualization</p>
            </div>
            <div class="mouse-info">
                <span>Click</span>: Add charge | <span>Drag</span>: Move charge | <span>Right-click</span>: Remove
            </div>
        </div>

        <div class="controls-panel">
            <div class="control-group">
                <h3>Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="chargeCount">0</div>
                        <div class="stat-label">Charges</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="netCharge">0</div>
                        <div class="stat-label">Net Charge</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="fieldStrength">0.00</div>
                        <div class="stat-label">Max Field</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="fpsDisplay">0</div>
                        <div class="stat-label">FPS</div>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3>Add Charge</h3>
                <div class="mode-buttons">
                    <button class="charge-btn positive active" id="addPositive">+ Positive</button>
                    <button class="charge-btn negative" id="addNegative">− Negative</button>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <label>Charge Magnitude <span id="magnitudeVal">1.0</span></label>
                    <input type="range" id="magnitude" min="1" max="50" value="10">
                </div>
            </div>

            <div class="control-group">
                <h3>Charges</h3>
                <div class="charge-list" id="chargeList">
                    <em style="color: #666;">No charges placed</em>
                </div>
            </div>

            <div class="control-group">
                <h3>Visualization</h3>
                <div class="checkbox-row">
                    <input type="checkbox" id="showFieldLines" checked>
                    <label for="showFieldLines">Field Lines</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="showVectors">
                    <label for="showVectors">Field Vectors</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="showEquipotential">
                    <label for="showEquipotential">Equipotential Lines</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="showHeatmap">
                    <label for="showHeatmap">Field Strength Heatmap</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="showTestCharge">
                    <label for="showTestCharge">Test Charge</label>
                </div>
            </div>

            <div class="control-group">
                <h3>Field Lines</h3>
                <div class="control-row">
                    <label>Lines per Charge <span id="linesPerChargeVal">16</span></label>
                    <input type="range" id="linesPerCharge" min="4" max="32" value="16">
                </div>
                <div class="control-row">
                    <label>Line Length <span id="lineLengthVal">200</span></label>
                    <input type="range" id="lineLength" min="50" max="500" value="200">
                </div>
            </div>

            <div class="control-group">
                <h3>Vector Field</h3>
                <div class="control-row">
                    <label>Grid Spacing <span id="gridSpacingVal">40</span></label>
                    <input type="range" id="gridSpacing" min="20" max="80" value="40">
                </div>
                <div class="control-row">
                    <label>Arrow Scale <span id="arrowScaleVal">1.0</span></label>
                    <input type="range" id="arrowScale" min="5" max="30" value="10">
                </div>
            </div>

            <div class="control-group">
                <h3>Presets</h3>
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="dipole">Dipole</button>
                    <button class="preset-btn" data-preset="quadrupole">Quadrupole</button>
                    <button class="preset-btn" data-preset="capacitor">Capacitor</button>
                    <button class="preset-btn" data-preset="ring">Ring</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Actions</h3>
                <div class="button-row">
                    <button class="btn primary" id="clearCharges">Clear All Charges</button>
                    <button class="btn secondary" id="resetTestCharge">Reset Test Charge</button>
                </div>
            </div>

            <div class="control-group">
                <h3>About</h3>
                <div class="info-box">
                    <strong>Coulomb's Law:</strong> F = kq₁q₂/r²<br><br>
                    <strong>Field Lines</strong> show the direction a positive test charge would move.<br><br>
                    <strong>Equipotential Lines</strong> connect points of equal electric potential.
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('fieldCanvas');
        const ctx = canvas.getContext('2d');

        // Constants
        const k = 8.99e9; // Coulomb's constant (scaled for visualization)
        const kVis = 1000; // Visualization scale

        // Settings
        let chargeSign = 1; // 1 for positive, -1 for negative
        let chargeMagnitude = 1;
        let showFieldLines = true;
        let showVectors = false;
        let showEquipotential = false;
        let showHeatmap = false;
        let showTestCharge = false;
        let linesPerCharge = 16;
        let lineLength = 200;
        let gridSpacing = 40;
        let arrowScale = 1;

        // State
        let charges = [];
        let testCharge = null;
        let selectedCharge = null;
        let dragging = false;
        let fps = 0;
        let lastTime = performance.now();
        let frameCount = 0;

        class Charge {
            constructor(x, y, q) {
                this.x = x;
                this.y = y;
                this.q = q; // Charge value (positive or negative)
            }

            get radius() {
                return 10 + Math.abs(this.q) * 2;
            }
        }

        class TestChargeParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.trail = [];
            }

            update() {
                const field = calculateField(this.x, this.y);
                const forceMag = Math.sqrt(field.x * field.x + field.y * field.y);

                if (forceMag > 0) {
                    const ax = field.x * 0.5;
                    const ay = field.y * 0.5;

                    this.vx += ax;
                    this.vy += ay;

                    // Limit velocity
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (speed > 10) {
                        this.vx = (this.vx / speed) * 10;
                        this.vy = (this.vy / speed) * 10;
                    }

                    this.vx *= 0.98;
                    this.vy *= 0.98;
                }

                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 100) this.trail.shift();

                this.x += this.vx;
                this.y += this.vy;

                // Wrap around edges
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }
        }

        function calculateField(x, y) {
            let Ex = 0, Ey = 0;

            for (const charge of charges) {
                const dx = x - charge.x;
                const dy = y - charge.y;
                const r2 = dx * dx + dy * dy;
                const r = Math.sqrt(r2);

                if (r < 5) continue; // Avoid singularity

                const E = kVis * charge.q / r2;
                Ex += E * dx / r;
                Ey += E * dy / r;
            }

            return { x: Ex, y: Ey };
        }

        function calculatePotential(x, y) {
            let V = 0;

            for (const charge of charges) {
                const dx = x - charge.x;
                const dy = y - charge.y;
                const r = Math.sqrt(dx * dx + dy * dy);

                if (r < 5) continue;

                V += kVis * charge.q / r;
            }

            return V;
        }

        function drawFieldLines() {
            ctx.lineWidth = 1.5;

            for (const charge of charges) {
                const numLines = Math.ceil(linesPerCharge * Math.abs(charge.q));

                for (let i = 0; i < numLines; i++) {
                    const angle = (i / numLines) * Math.PI * 2;
                    const startR = charge.radius + 5;

                    let x = charge.x + Math.cos(angle) * startR;
                    let y = charge.y + Math.sin(angle) * startR;

                    const direction = charge.q > 0 ? 1 : -1;

                    ctx.beginPath();
                    ctx.moveTo(x, y);

                    const gradient = ctx.createLinearGradient(
                        charge.x, charge.y,
                        charge.x + Math.cos(angle) * lineLength,
                        charge.y + Math.sin(angle) * lineLength
                    );
                    gradient.addColorStop(0, charge.q > 0 ? '#ff6b6b' : '#6b6bff');
                    gradient.addColorStop(1, 'rgba(255,255,255,0.1)');
                    ctx.strokeStyle = gradient;

                    for (let step = 0; step < lineLength; step++) {
                        const field = calculateField(x, y);
                        const mag = Math.sqrt(field.x * field.x + field.y * field.y);

                        if (mag < 0.001) break;

                        // Check if we hit another charge
                        let hitCharge = false;
                        for (const other of charges) {
                            if (other === charge) continue;
                            const dx = x - other.x;
                            const dy = y - other.y;
                            if (dx * dx + dy * dy < other.radius * other.radius) {
                                hitCharge = true;
                                break;
                            }
                        }
                        if (hitCharge) break;

                        // Move along field line
                        x += direction * (field.x / mag) * 3;
                        y += direction * (field.y / mag) * 3;

                        // Check bounds
                        if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) break;

                        ctx.lineTo(x, y);
                    }

                    ctx.stroke();
                }
            }
        }

        function drawVectorField() {
            ctx.lineWidth = 1;

            for (let x = gridSpacing / 2; x < canvas.width; x += gridSpacing) {
                for (let y = gridSpacing / 2; y < canvas.height; y += gridSpacing) {
                    // Skip near charges
                    let nearCharge = false;
                    for (const charge of charges) {
                        const dx = x - charge.x;
                        const dy = y - charge.y;
                        if (dx * dx + dy * dy < (charge.radius + 10) ** 2) {
                            nearCharge = true;
                            break;
                        }
                    }
                    if (nearCharge) continue;

                    const field = calculateField(x, y);
                    const mag = Math.sqrt(field.x * field.x + field.y * field.y);

                    if (mag < 0.01) continue;

                    // Normalize and scale
                    const length = Math.min(mag * arrowScale, gridSpacing * 0.8);
                    const dx = (field.x / mag) * length;
                    const dy = (field.y / mag) * length;

                    // Color based on magnitude
                    const intensity = Math.min(mag / 10, 1);
                    const hue = 60 - intensity * 60; // Yellow to red
                    ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.fillStyle = ctx.strokeStyle;

                    // Draw arrow
                    ctx.beginPath();
                    ctx.moveTo(x - dx / 2, y - dy / 2);
                    ctx.lineTo(x + dx / 2, y + dy / 2);
                    ctx.stroke();

                    // Arrowhead
                    const angle = Math.atan2(dy, dx);
                    const headLength = 5;
                    ctx.beginPath();
                    ctx.moveTo(x + dx / 2, y + dy / 2);
                    ctx.lineTo(
                        x + dx / 2 - headLength * Math.cos(angle - Math.PI / 6),
                        y + dy / 2 - headLength * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        x + dx / 2 - headLength * Math.cos(angle + Math.PI / 6),
                        y + dy / 2 - headLength * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        function drawEquipotential() {
            if (charges.length === 0) return;

            const levels = [-50, -20, -10, -5, -2, 2, 5, 10, 20, 50];

            ctx.lineWidth = 1;

            // Use marching squares-like approach
            const resolution = 5;

            for (const level of levels) {
                ctx.strokeStyle = level > 0 ? 'rgba(255, 100, 100, 0.4)' : 'rgba(100, 100, 255, 0.4)';

                // Find contour points
                for (let x = 0; x < canvas.width; x += resolution) {
                    for (let y = 0; y < canvas.height; y += resolution) {
                        const v00 = calculatePotential(x, y);
                        const v10 = calculatePotential(x + resolution, y);
                        const v01 = calculatePotential(x, y + resolution);
                        const v11 = calculatePotential(x + resolution, y + resolution);

                        // Check if contour crosses this cell
                        const crossesTop = (v00 - level) * (v10 - level) < 0;
                        const crossesBottom = (v01 - level) * (v11 - level) < 0;
                        const crossesLeft = (v00 - level) * (v01 - level) < 0;
                        const crossesRight = (v10 - level) * (v11 - level) < 0;

                        if (crossesTop || crossesBottom || crossesLeft || crossesRight) {
                            const points = [];

                            if (crossesTop) {
                                const t = (level - v00) / (v10 - v00);
                                points.push({ x: x + t * resolution, y: y });
                            }
                            if (crossesBottom) {
                                const t = (level - v01) / (v11 - v01);
                                points.push({ x: x + t * resolution, y: y + resolution });
                            }
                            if (crossesLeft) {
                                const t = (level - v00) / (v01 - v00);
                                points.push({ x: x, y: y + t * resolution });
                            }
                            if (crossesRight) {
                                const t = (level - v10) / (v11 - v10);
                                points.push({ x: x + resolution, y: y + t * resolution });
                            }

                            if (points.length >= 2) {
                                ctx.beginPath();
                                ctx.moveTo(points[0].x, points[0].y);
                                ctx.lineTo(points[1].x, points[1].y);
                                ctx.stroke();
                            }
                        }
                    }
                }
            }
        }

        function drawHeatmap() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            let maxField = 0;
            const fieldValues = [];

            // Calculate field magnitude for each pixel (downsampled)
            const step = 4;
            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const field = calculateField(x, y);
                    const mag = Math.sqrt(field.x * field.x + field.y * field.y);
                    fieldValues.push({ x, y, mag });
                    maxField = Math.max(maxField, mag);
                }
            }

            document.getElementById('fieldStrength').textContent = maxField.toFixed(2);

            // Draw heatmap
            for (const { x, y, mag } of fieldValues) {
                const normalized = Math.min(mag / (maxField * 0.3), 1);
                const hue = 240 - normalized * 240; // Blue to red
                const [r, g, b] = hslToRgb(hue / 360, 0.8, 0.3 + normalized * 0.3);

                for (let dy = 0; dy < step; dy++) {
                    for (let dx = 0; dx < step; dx++) {
                        const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = 150;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function drawCharges() {
            for (const charge of charges) {
                const gradient = ctx.createRadialGradient(
                    charge.x - charge.radius * 0.3,
                    charge.y - charge.radius * 0.3,
                    0,
                    charge.x,
                    charge.y,
                    charge.radius
                );

                if (charge.q > 0) {
                    gradient.addColorStop(0, '#ff8888');
                    gradient.addColorStop(1, '#cc0000');
                } else {
                    gradient.addColorStop(0, '#8888ff');
                    gradient.addColorStop(1, '#0000cc');
                }

                ctx.beginPath();
                ctx.arc(charge.x, charge.y, charge.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = charge === selectedCharge ? '#fff' : 'rgba(255,255,255,0.5)';
                ctx.lineWidth = charge === selectedCharge ? 3 : 1;
                ctx.stroke();

                // Draw + or - symbol
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${charge.radius}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(charge.q > 0 ? '+' : '−', charge.x, charge.y);
            }
        }

        function drawTestCharge() {
            if (!testCharge) return;

            // Draw trail
            if (testCharge.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(testCharge.trail[0].x, testCharge.trail[0].y);
                for (let i = 1; i < testCharge.trail.length; i++) {
                    ctx.lineTo(testCharge.trail[i].x, testCharge.trail[i].y);
                }
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw particle
            ctx.beginPath();
            ctx.arc(testCharge.x, testCharge.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#00ff00';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function updateChargeList() {
            const list = document.getElementById('chargeList');

            if (charges.length === 0) {
                list.innerHTML = '<em style="color: #666;">No charges placed</em>';
                return;
            }

            list.innerHTML = charges.map((c, i) => `
                <div class="charge-item ${c.q > 0 ? 'positive' : 'negative'}">
                    <span>${c.q > 0 ? '+' : ''}${c.q.toFixed(1)} at (${Math.round(c.x)}, ${Math.round(c.y)})</span>
                    <button onclick="removeCharge(${i})">×</button>
                </div>
            `).join('');
        }

        function removeCharge(index) {
            charges.splice(index, 1);
            updateChargeList();
            updateStats();
        }

        function updateStats() {
            document.getElementById('chargeCount').textContent = charges.length;

            const netCharge = charges.reduce((sum, c) => sum + c.q, 0);
            document.getElementById('netCharge').textContent = (netCharge >= 0 ? '+' : '') + netCharge.toFixed(1);
        }

        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (showHeatmap && charges.length > 0) {
                drawHeatmap();
            }

            if (showEquipotential && charges.length > 0) {
                drawEquipotential();
            }

            if (showFieldLines && charges.length > 0) {
                drawFieldLines();
            }

            if (showVectors && charges.length > 0) {
                drawVectorField();
            }

            drawCharges();

            if (showTestCharge && testCharge) {
                drawTestCharge();
            }
        }

        function update() {
            if (showTestCharge && testCharge) {
                testCharge.update();
            }
        }

        function animate() {
            update();
            draw();

            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                document.getElementById('fpsDisplay').textContent = fps;
            }

            requestAnimationFrame(animate);
        }

        function findChargeAt(x, y) {
            for (const charge of charges) {
                const dx = x - charge.x;
                const dy = y - charge.y;
                if (dx * dx + dy * dy < charge.radius ** 2) {
                    return charge;
                }
            }
            return null;
        }

        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }

        // Event listeners
        document.getElementById('addPositive').addEventListener('click', () => {
            chargeSign = 1;
            document.getElementById('addPositive').classList.add('active');
            document.getElementById('addNegative').classList.remove('active');
        });

        document.getElementById('addNegative').addEventListener('click', () => {
            chargeSign = -1;
            document.getElementById('addNegative').classList.add('active');
            document.getElementById('addPositive').classList.remove('active');
        });

        document.getElementById('magnitude').addEventListener('input', e => {
            chargeMagnitude = parseInt(e.target.value) / 10;
            document.getElementById('magnitudeVal').textContent = chargeMagnitude.toFixed(1);
        });

        document.getElementById('showFieldLines').addEventListener('change', e => {
            showFieldLines = e.target.checked;
        });

        document.getElementById('showVectors').addEventListener('change', e => {
            showVectors = e.target.checked;
        });

        document.getElementById('showEquipotential').addEventListener('change', e => {
            showEquipotential = e.target.checked;
        });

        document.getElementById('showHeatmap').addEventListener('change', e => {
            showHeatmap = e.target.checked;
        });

        document.getElementById('showTestCharge').addEventListener('change', e => {
            showTestCharge = e.target.checked;
            if (showTestCharge && !testCharge) {
                testCharge = new TestChargeParticle(canvas.width / 2, canvas.height / 2);
            }
        });

        document.getElementById('linesPerCharge').addEventListener('input', e => {
            linesPerCharge = parseInt(e.target.value);
            document.getElementById('linesPerChargeVal').textContent = linesPerCharge;
        });

        document.getElementById('lineLength').addEventListener('input', e => {
            lineLength = parseInt(e.target.value);
            document.getElementById('lineLengthVal').textContent = lineLength;
        });

        document.getElementById('gridSpacing').addEventListener('input', e => {
            gridSpacing = parseInt(e.target.value);
            document.getElementById('gridSpacingVal').textContent = gridSpacing;
        });

        document.getElementById('arrowScale').addEventListener('input', e => {
            arrowScale = parseInt(e.target.value) / 10;
            document.getElementById('arrowScaleVal').textContent = arrowScale.toFixed(1);
        });

        document.getElementById('clearCharges').addEventListener('click', () => {
            charges = [];
            updateChargeList();
            updateStats();
        });

        document.getElementById('resetTestCharge').addEventListener('click', () => {
            testCharge = new TestChargeParticle(canvas.width / 2, canvas.height / 2);
        });

        // Presets
        const presets = {
            dipole: () => {
                charges = [
                    new Charge(canvas.width / 2 - 80, canvas.height / 2, 2),
                    new Charge(canvas.width / 2 + 80, canvas.height / 2, -2)
                ];
            },
            quadrupole: () => {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const d = 80;
                charges = [
                    new Charge(cx - d, cy - d, 2),
                    new Charge(cx + d, cy - d, -2),
                    new Charge(cx - d, cy + d, -2),
                    new Charge(cx + d, cy + d, 2)
                ];
            },
            capacitor: () => {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                charges = [];
                for (let i = -3; i <= 3; i++) {
                    charges.push(new Charge(cx - 100, cy + i * 40, 1));
                    charges.push(new Charge(cx + 100, cy + i * 40, -1));
                }
            },
            ring: () => {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const r = 120;
                charges = [];
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    charges.push(new Charge(
                        cx + Math.cos(angle) * r,
                        cy + Math.sin(angle) * r,
                        i % 2 === 0 ? 1 : -1
                    ));
                }
            }
        };

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                presets[btn.dataset.preset]();
                updateChargeList();
                updateStats();
            });
        });

        // Mouse interactions
        canvas.addEventListener('mousedown', e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (e.button === 2) {
                // Right click - remove charge
                const charge = findChargeAt(x, y);
                if (charge) {
                    charges = charges.filter(c => c !== charge);
                    updateChargeList();
                    updateStats();
                }
            } else {
                // Left click - add or drag
                const charge = findChargeAt(x, y);
                if (charge) {
                    selectedCharge = charge;
                    dragging = true;
                } else {
                    charges.push(new Charge(x, y, chargeSign * chargeMagnitude));
                    updateChargeList();
                    updateStats();
                }
            }
        });

        canvas.addEventListener('mousemove', e => {
            if (dragging && selectedCharge) {
                const rect = canvas.getBoundingClientRect();
                selectedCharge.x = e.clientX - rect.left;
                selectedCharge.y = e.clientY - rect.top;
                updateChargeList();
            }
        });

        canvas.addEventListener('mouseup', () => {
            dragging = false;
            selectedCharge = null;
        });

        canvas.addEventListener('mouseleave', () => {
            dragging = false;
            selectedCharge = null;
        });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('resize', resize);

        // Initialize
        resize();
        animate();
    </script>
</body>
</html>
