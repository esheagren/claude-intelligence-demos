<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Glitch Effect</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            display: flex;
        }

        .sidebar {
            width: 300px;
            background: #111118;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #222;
            flex-shrink: 0;
        }

        .sidebar h1 {
            font-size: 22px;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #ff0080, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 12px;
            color: #666;
            margin-bottom: 20px;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 12px;
        }

        .control {
            margin-bottom: 15px;
        }

        .control label {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: #ccc;
            margin-bottom: 6px;
        }

        .control .value {
            color: #00ffff;
            font-family: monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff0080, #00ffff);
            cursor: pointer;
        }

        .checkbox-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .checkbox-control input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-control label {
            font-size: 13px;
            color: #ccc;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #222;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            margin-bottom: 8px;
        }

        button:hover {
            background: #333;
        }

        button.primary {
            background: linear-gradient(135deg, #ff0080, #00ffff);
            color: #000;
            font-weight: bold;
        }

        button.danger {
            background: #c0392b;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px;
            font-size: 11px;
            text-transform: uppercase;
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #ff0080, #00ffff);
            color: #000;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }

        .drop-zone {
            width: 100%;
            max-width: 800px;
            aspect-ratio: 16/9;
            border: 3px dashed #333;
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.02);
        }

        .drop-zone:hover, .drop-zone.drag-over {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.05);
        }

        .drop-zone.hidden {
            display: none;
        }

        .drop-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .drop-text {
            font-size: 18px;
            color: #888;
            margin-bottom: 10px;
        }

        .drop-hint {
            font-size: 13px;
            color: #555;
        }

        .canvas-container {
            position: relative;
            display: none;
        }

        .canvas-container.visible {
            display: block;
        }

        #glitchCanvas {
            max-width: 100%;
            max-height: 80vh;
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .input-file {
            display: none;
        }

        .comparison-slider {
            position: absolute;
            top: 0;
            left: 50%;
            width: 4px;
            height: 100%;
            background: #fff;
            cursor: ew-resize;
            z-index: 10;
            display: none;
        }

        .comparison-slider::before {
            content: '‚óÑ‚ñ∫';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            color: #000;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
        }

        .action-bar {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .action-bar button {
            width: auto;
            padding: 10px 25px;
            margin: 0;
        }

        .glitch-scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .glitch-scanlines.visible {
            opacity: 1;
        }

        .live-preview {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .live-indicator {
            width: 8px;
            height: 8px;
            background: #ff0080;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .divider {
            height: 1px;
            background: #222;
            margin: 20px 0;
        }

        @media (max-width: 900px) {
            .sidebar {
                position: fixed;
                left: -300px;
                top: 0;
                height: 100%;
                z-index: 100;
                transition: left 0.3s;
            }

            .sidebar.open {
                left: 0;
            }

            .mobile-toggle {
                display: block;
                position: fixed;
                top: 20px;
                left: 20px;
                z-index: 101;
                width: 40px;
                height: 40px;
                background: #222;
                border-radius: 8px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="glitch-scanlines" id="scanlines"></div>

    <div class="sidebar" id="sidebar">
        <h1>Glitch Lab</h1>
        <p class="subtitle">Image distortion effects</p>

        <div class="section">
            <h3>Presets</h3>
            <div class="preset-grid">
                <button class="preset-btn" data-preset="vhs">VHS</button>
                <button class="preset-btn" data-preset="digital">Digital</button>
                <button class="preset-btn" data-preset="corrupt">Corrupt</button>
                <button class="preset-btn" data-preset="retro">Retro</button>
                <button class="preset-btn" data-preset="cyber">Cyber</button>
                <button class="preset-btn" data-preset="chaos">Chaos</button>
            </div>
        </div>

        <div class="divider"></div>

        <div class="section">
            <h3>RGB Split</h3>
            <div class="control">
                <label>Intensity <span class="value" id="rgbVal">0</span></label>
                <input type="range" id="rgbSplit" min="0" max="50" value="0">
            </div>
            <div class="control">
                <label>Angle <span class="value" id="rgbAngleVal">0¬∞</span></label>
                <input type="range" id="rgbAngle" min="0" max="360" value="0">
            </div>
        </div>

        <div class="section">
            <h3>Scanlines</h3>
            <div class="control">
                <label>Intensity <span class="value" id="scanVal">0</span></label>
                <input type="range" id="scanlines" min="0" max="100" value="0">
            </div>
            <div class="control">
                <label>Gap <span class="value" id="scanGapVal">2</span></label>
                <input type="range" id="scanlineGap" min="1" max="10" value="2">
            </div>
        </div>

        <div class="section">
            <h3>Noise</h3>
            <div class="control">
                <label>Amount <span class="value" id="noiseVal">0</span></label>
                <input type="range" id="noise" min="0" max="100" value="0">
            </div>
            <div class="checkbox-control">
                <input type="checkbox" id="colorNoise">
                <label for="colorNoise">Color Noise</label>
            </div>
        </div>

        <div class="section">
            <h3>Displacement</h3>
            <div class="control">
                <label>Horizontal <span class="value" id="dispXVal">0</span></label>
                <input type="range" id="displaceX" min="0" max="50" value="0">
            </div>
            <div class="control">
                <label>Segments <span class="value" id="segVal">5</span></label>
                <input type="range" id="segments" min="1" max="30" value="5">
            </div>
        </div>

        <div class="section">
            <h3>Effects</h3>
            <div class="control">
                <label>Pixelate <span class="value" id="pixelVal">1</span></label>
                <input type="range" id="pixelate" min="1" max="30" value="1">
            </div>
            <div class="control">
                <label>Posterize <span class="value" id="posterVal">256</span></label>
                <input type="range" id="posterize" min="2" max="256" value="256">
            </div>
            <div class="control">
                <label>Contrast <span class="value" id="contrastVal">0</span></label>
                <input type="range" id="contrast" min="-100" max="100" value="0">
            </div>
        </div>

        <div class="section">
            <h3>Color</h3>
            <div class="control">
                <label>Hue Shift <span class="value" id="hueVal">0¬∞</span></label>
                <input type="range" id="hueShift" min="0" max="360" value="0">
            </div>
            <div class="control">
                <label>Saturation <span class="value" id="satVal">100%</span></label>
                <input type="range" id="saturation" min="0" max="200" value="100">
            </div>
            <div class="checkbox-control">
                <input type="checkbox" id="invert">
                <label for="invert">Invert Colors</label>
            </div>
        </div>

        <div class="divider"></div>

        <button class="primary" id="uploadBtn">Upload Image</button>
        <button id="randomBtn">Random Glitch</button>
        <button id="animateBtn">Animate</button>
        <button id="resetBtn">Reset All</button>
        <button class="primary" id="downloadBtn">Download PNG</button>

        <div class="live-preview">
            <div class="live-indicator"></div>
            <span>Live preview enabled</span>
        </div>
    </div>

    <div class="canvas-area">
        <div class="drop-zone" id="dropZone">
            <div class="drop-icon">üñºÔ∏è</div>
            <div class="drop-text">Drop an image here</div>
            <div class="drop-hint">or click to browse</div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="glitchCanvas"></canvas>
        </div>

        <div class="action-bar" id="actionBar" style="display: none;">
            <button id="newImageBtn">New Image</button>
        </div>
    </div>

    <input type="file" id="fileInput" class="input-file" accept="image/*">

    <script>
        const canvas = document.getElementById('glitchCanvas');
        const ctx = canvas.getContext('2d');
        const dropZone = document.getElementById('dropZone');
        const canvasContainer = document.getElementById('canvasContainer');
        const fileInput = document.getElementById('fileInput');

        let originalImage = null;
        let originalImageData = null;
        let animationFrame = null;
        let isAnimating = false;

        // Effect parameters
        const params = {
            rgbSplit: 0,
            rgbAngle: 0,
            scanlines: 0,
            scanlineGap: 2,
            noise: 0,
            colorNoise: false,
            displaceX: 0,
            segments: 5,
            pixelate: 1,
            posterize: 256,
            contrast: 0,
            hueShift: 0,
            saturation: 100,
            invert: false
        };

        // Presets
        const presets = {
            vhs: { rgbSplit: 8, scanlines: 30, noise: 15, displaceX: 5, segments: 8 },
            digital: { rgbSplit: 15, rgbAngle: 45, displaceX: 20, segments: 15 },
            corrupt: { displaceX: 30, segments: 20, noise: 40, pixelate: 3 },
            retro: { scanlines: 50, scanlineGap: 3, posterize: 16, saturation: 150 },
            cyber: { rgbSplit: 20, hueShift: 180, contrast: 30, scanlines: 20 },
            chaos: { rgbSplit: 25, displaceX: 40, noise: 50, pixelate: 2, posterize: 8 }
        };

        function loadImage(src) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                originalImage = img;

                // Limit canvas size
                const maxSize = 1200;
                let width = img.width;
                let height = img.height;

                if (width > maxSize || height > maxSize) {
                    if (width > height) {
                        height = (height / width) * maxSize;
                        width = maxSize;
                    } else {
                        width = (width / height) * maxSize;
                        height = maxSize;
                    }
                }

                canvas.width = width;
                canvas.height = height;

                ctx.drawImage(img, 0, 0, width, height);
                originalImageData = ctx.getImageData(0, 0, width, height);

                dropZone.classList.add('hidden');
                canvasContainer.classList.add('visible');
                document.getElementById('actionBar').style.display = 'flex';

                applyEffects();
            };
            img.src = src;
        }

        function applyEffects() {
            if (!originalImageData) return;

            // Start with original
            const imageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );

            // Apply pixelation first
            if (params.pixelate > 1) {
                applyPixelate(imageData, params.pixelate);
            }

            // Apply posterize
            if (params.posterize < 256) {
                applyPosterize(imageData, params.posterize);
            }

            // Apply contrast
            if (params.contrast !== 0) {
                applyContrast(imageData, params.contrast);
            }

            // Apply hue shift
            if (params.hueShift !== 0) {
                applyHueShift(imageData, params.hueShift);
            }

            // Apply saturation
            if (params.saturation !== 100) {
                applySaturation(imageData, params.saturation / 100);
            }

            // Apply invert
            if (params.invert) {
                applyInvert(imageData);
            }

            // Apply noise
            if (params.noise > 0) {
                applyNoise(imageData, params.noise, params.colorNoise);
            }

            ctx.putImageData(imageData, 0, 0);

            // Apply displacement (requires reading back)
            if (params.displaceX > 0) {
                applyDisplacement(params.displaceX, params.segments);
            }

            // Apply RGB split
            if (params.rgbSplit > 0) {
                applyRGBSplit(params.rgbSplit, params.rgbAngle);
            }

            // Apply scanlines
            if (params.scanlines > 0) {
                applyScanlines(params.scanlines, params.scanlineGap);
            }
        }

        function applyPixelate(imageData, size) {
            const { data, width, height } = imageData;

            for (let y = 0; y < height; y += size) {
                for (let x = 0; x < width; x += size) {
                    // Get average color of block
                    let r = 0, g = 0, b = 0, count = 0;

                    for (let dy = 0; dy < size && y + dy < height; dy++) {
                        for (let dx = 0; dx < size && x + dx < width; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            r += data[idx];
                            g += data[idx + 1];
                            b += data[idx + 2];
                            count++;
                        }
                    }

                    r = Math.round(r / count);
                    g = Math.round(g / count);
                    b = Math.round(b / count);

                    // Apply average to all pixels in block
                    for (let dy = 0; dy < size && y + dy < height; dy++) {
                        for (let dx = 0; dx < size && x + dx < width; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                        }
                    }
                }
            }
        }

        function applyPosterize(imageData, levels) {
            const { data } = imageData;
            const step = 255 / (levels - 1);

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.round(Math.round(data[i] / step) * step);
                data[i + 1] = Math.round(Math.round(data[i + 1] / step) * step);
                data[i + 2] = Math.round(Math.round(data[i + 2] / step) * step);
            }
        }

        function applyContrast(imageData, amount) {
            const { data } = imageData;
            const factor = (259 * (amount + 255)) / (255 * (259 - amount));

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.max(0, Math.min(255, factor * (data[i] - 128) + 128));
                data[i + 1] = Math.max(0, Math.min(255, factor * (data[i + 1] - 128) + 128));
                data[i + 2] = Math.max(0, Math.min(255, factor * (data[i + 2] - 128) + 128));
            }
        }

        function applyHueShift(imageData, degrees) {
            const { data } = imageData;

            for (let i = 0; i < data.length; i += 4) {
                const [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
                const [r, g, b] = hslToRgb((h + degrees / 360) % 1, s, l);
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
        }

        function applySaturation(imageData, factor) {
            const { data } = imageData;

            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.2989 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                data[i] = Math.max(0, Math.min(255, gray + factor * (data[i] - gray)));
                data[i + 1] = Math.max(0, Math.min(255, gray + factor * (data[i + 1] - gray)));
                data[i + 2] = Math.max(0, Math.min(255, gray + factor * (data[i + 2] - gray)));
            }
        }

        function applyInvert(imageData) {
            const { data } = imageData;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2];
            }
        }

        function applyNoise(imageData, amount, colorNoise) {
            const { data } = imageData;
            const intensity = amount / 100 * 255;

            for (let i = 0; i < data.length; i += 4) {
                if (colorNoise) {
                    data[i] = Math.max(0, Math.min(255, data[i] + (Math.random() - 0.5) * intensity));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + (Math.random() - 0.5) * intensity));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + (Math.random() - 0.5) * intensity));
                } else {
                    const noise = (Math.random() - 0.5) * intensity;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
                }
            }
        }

        function applyDisplacement(amount, segments) {
            const { width, height } = canvas;
            const imageData = ctx.getImageData(0, 0, width, height);
            const result = new ImageData(width, height);

            const segmentHeight = Math.ceil(height / segments);

            for (let seg = 0; seg < segments; seg++) {
                const offset = (Math.random() - 0.5) * amount * 2;
                const startY = seg * segmentHeight;
                const endY = Math.min(startY + segmentHeight, height);

                for (let y = startY; y < endY; y++) {
                    for (let x = 0; x < width; x++) {
                        const srcX = Math.floor(x - offset + width) % width;
                        const srcIdx = (y * width + srcX) * 4;
                        const dstIdx = (y * width + x) * 4;

                        result.data[dstIdx] = imageData.data[srcIdx];
                        result.data[dstIdx + 1] = imageData.data[srcIdx + 1];
                        result.data[dstIdx + 2] = imageData.data[srcIdx + 2];
                        result.data[dstIdx + 3] = imageData.data[srcIdx + 3];
                    }
                }
            }

            ctx.putImageData(result, 0, 0);
        }

        function applyRGBSplit(amount, angle) {
            const { width, height } = canvas;
            const imageData = ctx.getImageData(0, 0, width, height);

            const radians = angle * Math.PI / 180;
            const offsetX = Math.cos(radians) * amount;
            const offsetY = Math.sin(radians) * amount;

            const result = new ImageData(width, height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;

                    // Red channel - offset in one direction
                    const rx = Math.floor(x - offsetX + width) % width;
                    const ry = Math.floor(y - offsetY + height) % height;
                    const rIdx = (ry * width + rx) * 4;

                    // Blue channel - offset in opposite direction
                    const bx = Math.floor(x + offsetX + width) % width;
                    const by = Math.floor(y + offsetY + height) % height;
                    const bIdx = (by * width + bx) * 4;

                    result.data[idx] = imageData.data[rIdx]; // Red
                    result.data[idx + 1] = imageData.data[idx + 1]; // Green stays
                    result.data[idx + 2] = imageData.data[bIdx + 2]; // Blue
                    result.data[idx + 3] = 255;
                }
            }

            ctx.putImageData(result, 0, 0);
        }

        function applyScanlines(intensity, gap) {
            const { width, height } = canvas;

            ctx.fillStyle = `rgba(0, 0, 0, ${intensity / 100})`;

            for (let y = 0; y < height; y += gap * 2) {
                ctx.fillRect(0, y, width, gap);
            }
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return [h, s, l];
        }

        function hslToRgb(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function randomGlitch() {
            params.rgbSplit = Math.random() * 30;
            params.rgbAngle = Math.random() * 360;
            params.scanlines = Math.random() * 50;
            params.noise = Math.random() * 40;
            params.displaceX = Math.random() * 30;
            params.segments = Math.floor(Math.random() * 20) + 5;
            params.pixelate = Math.floor(Math.random() * 5) + 1;
            params.posterize = Math.floor(Math.random() * 200) + 8;
            params.hueShift = Math.random() * 360;

            updateSliders();
            applyEffects();
        }

        function resetAll() {
            Object.keys(params).forEach(key => {
                if (typeof params[key] === 'boolean') {
                    params[key] = false;
                } else if (key === 'posterize') {
                    params[key] = 256;
                } else if (key === 'saturation') {
                    params[key] = 100;
                } else if (key === 'pixelate' || key === 'scanlineGap') {
                    params[key] = key === 'scanlineGap' ? 2 : 1;
                } else if (key === 'segments') {
                    params[key] = 5;
                } else {
                    params[key] = 0;
                }
            });

            updateSliders();
            applyEffects();
        }

        function updateSliders() {
            document.getElementById('rgbSplit').value = params.rgbSplit;
            document.getElementById('rgbAngle').value = params.rgbAngle;
            document.getElementById('scanlines').value = params.scanlines;
            document.getElementById('scanlineGap').value = params.scanlineGap;
            document.getElementById('noise').value = params.noise;
            document.getElementById('colorNoise').checked = params.colorNoise;
            document.getElementById('displaceX').value = params.displaceX;
            document.getElementById('segments').value = params.segments;
            document.getElementById('pixelate').value = params.pixelate;
            document.getElementById('posterize').value = params.posterize;
            document.getElementById('contrast').value = params.contrast;
            document.getElementById('hueShift').value = params.hueShift;
            document.getElementById('saturation').value = params.saturation;
            document.getElementById('invert').checked = params.invert;

            updateValues();
        }

        function updateValues() {
            document.getElementById('rgbVal').textContent = Math.round(params.rgbSplit);
            document.getElementById('rgbAngleVal').textContent = Math.round(params.rgbAngle) + '¬∞';
            document.getElementById('scanVal').textContent = Math.round(params.scanlines);
            document.getElementById('scanGapVal').textContent = params.scanlineGap;
            document.getElementById('noiseVal').textContent = Math.round(params.noise);
            document.getElementById('dispXVal').textContent = Math.round(params.displaceX);
            document.getElementById('segVal').textContent = params.segments;
            document.getElementById('pixelVal').textContent = params.pixelate;
            document.getElementById('posterVal').textContent = params.posterize;
            document.getElementById('contrastVal').textContent = params.contrast;
            document.getElementById('hueVal').textContent = Math.round(params.hueShift) + '¬∞';
            document.getElementById('satVal').textContent = params.saturation + '%';
        }

        function loadPreset(name) {
            resetAll();
            const preset = presets[name];
            Object.assign(params, preset);
            updateSliders();
            applyEffects();

            document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-preset="${name}"]`)?.classList.add('active');
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            document.getElementById('animateBtn').textContent = isAnimating ? 'Stop' : 'Animate';

            if (isAnimating) {
                animate();
            } else {
                cancelAnimationFrame(animationFrame);
            }
        }

        function animate() {
            if (!isAnimating) return;

            // Randomize some parameters slightly
            if (params.displaceX > 0) {
                applyEffects();
            }
            if (params.noise > 0) {
                applyEffects();
            }

            animationFrame = requestAnimationFrame(animate);
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = `glitch-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // Event listeners
        dropZone.addEventListener('click', () => fileInput.click());
        document.getElementById('uploadBtn').addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => loadImage(e.target.result);
                reader.readAsDataURL(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => loadImage(e.target.result);
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('newImageBtn').addEventListener('click', () => {
            originalImage = null;
            originalImageData = null;
            dropZone.classList.remove('hidden');
            canvasContainer.classList.remove('visible');
            document.getElementById('actionBar').style.display = 'none';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        // Slider listeners
        const sliderMappings = {
            rgbSplit: 'rgbSplit',
            rgbAngle: 'rgbAngle',
            scanlines: 'scanlines',
            scanlineGap: 'scanlineGap',
            noise: 'noise',
            displaceX: 'displaceX',
            segments: 'segments',
            pixelate: 'pixelate',
            posterize: 'posterize',
            contrast: 'contrast',
            hueShift: 'hueShift',
            saturation: 'saturation'
        };

        Object.entries(sliderMappings).forEach(([id, param]) => {
            document.getElementById(id).addEventListener('input', (e) => {
                params[param] = parseFloat(e.target.value);
                updateValues();
                applyEffects();
            });
        });

        document.getElementById('colorNoise').addEventListener('change', (e) => {
            params.colorNoise = e.target.checked;
            applyEffects();
        });

        document.getElementById('invert').addEventListener('change', (e) => {
            params.invert = e.target.checked;
            applyEffects();
        });

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => loadPreset(btn.dataset.preset));
        });

        document.getElementById('randomBtn').addEventListener('click', randomGlitch);
        document.getElementById('resetBtn').addEventListener('click', resetAll);
        document.getElementById('animateBtn').addEventListener('click', toggleAnimation);
        document.getElementById('downloadBtn').addEventListener('click', downloadImage);

        // Load demo image
        const demoCanvas = document.createElement('canvas');
        demoCanvas.width = 400;
        demoCanvas.height = 300;
        const demoCtx = demoCanvas.getContext('2d');

        // Create gradient demo image
        const gradient = demoCtx.createLinearGradient(0, 0, 400, 300);
        gradient.addColorStop(0, '#ff0080');
        gradient.addColorStop(0.5, '#00ffff');
        gradient.addColorStop(1, '#ffff00');
        demoCtx.fillStyle = gradient;
        demoCtx.fillRect(0, 0, 400, 300);

        // Add some shapes
        demoCtx.fillStyle = '#fff';
        demoCtx.beginPath();
        demoCtx.arc(200, 150, 80, 0, Math.PI * 2);
        demoCtx.fill();

        demoCtx.fillStyle = '#000';
        demoCtx.fillRect(150, 100, 100, 100);
    </script>
</body>
</html>
