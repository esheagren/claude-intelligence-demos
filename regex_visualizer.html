<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regex Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.3), rgba(118, 75, 162, 0.3));
            border-radius: 12px;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2em;
            font-weight: 500;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #888;
            font-size: 1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #333;
        }

        .panel-title {
            font-size: 0.9em;
            color: #667eea;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-label {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 6px;
            display: block;
        }

        .regex-input-container {
            display: flex;
            align-items: center;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 8px;
            border: 1px solid #444;
            overflow: hidden;
        }

        .regex-delimiter {
            padding: 12px;
            color: #667eea;
            font-size: 1.2em;
            font-weight: bold;
        }

        #regex-input {
            flex: 1;
            padding: 12px 0;
            background: transparent;
            border: none;
            color: #e0e0e0;
            font-size: 1.1em;
            font-family: 'Courier New', monospace;
            outline: none;
        }

        .flags-container {
            display: flex;
            gap: 5px;
            padding-right: 10px;
        }

        .flag-btn {
            padding: 6px 10px;
            background: rgba(60, 60, 80, 0.5);
            border: 1px solid #444;
            color: #888;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .flag-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        #test-input {
            width: 100%;
            padding: 15px;
            background: rgba(30, 30, 50, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 1em;
            font-family: 'Courier New', monospace;
            outline: none;
            min-height: 100px;
            resize: vertical;
        }

        .error-message {
            color: #ff6b6b;
            font-size: 0.85em;
            margin-top: 8px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }

        .diagram-container {
            min-height: 200px;
            overflow-x: auto;
            background: rgba(15, 15, 25, 0.5);
            border-radius: 8px;
            padding: 20px;
        }

        #diagram-canvas {
            display: block;
            margin: 0 auto;
        }

        .matches-container {
            max-height: 300px;
            overflow-y: auto;
        }

        .match-item {
            background: rgba(40, 40, 60, 0.5);
            padding: 12px 15px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
        }

        .match-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .match-index {
            color: #667eea;
            font-weight: 500;
        }

        .match-position {
            color: #888;
        }

        .match-text {
            color: #50fa7b;
            word-break: break-all;
        }

        .match-groups {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
            font-size: 0.85em;
        }

        .group-item {
            display: flex;
            gap: 10px;
            margin-bottom: 4px;
        }

        .group-index {
            color: #ff79c6;
        }

        .group-value {
            color: #f1fa8c;
        }

        .highlighted-text {
            line-height: 1.8;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .highlight {
            background: rgba(80, 250, 123, 0.3);
            border-radius: 2px;
            padding: 2px 0;
        }

        .highlight:nth-child(odd) {
            background: rgba(241, 250, 140, 0.3);
        }

        .examples-grid {
            display: grid;
            gap: 8px;
        }

        .example-btn {
            padding: 10px 15px;
            background: rgba(60, 60, 80, 0.5);
            border: 1px solid #444;
            color: #aaa;
            border-radius: 6px;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
            font-size: 0.85em;
        }

        .example-btn:hover {
            background: rgba(80, 80, 100, 0.6);
            color: white;
        }

        .example-pattern {
            font-family: monospace;
            color: #667eea;
            display: block;
            margin-bottom: 4px;
        }

        .example-desc {
            color: #888;
            font-size: 0.9em;
        }

        .cheatsheet {
            font-size: 0.85em;
        }

        .cheat-category {
            margin-bottom: 15px;
        }

        .cheat-title {
            color: #667eea;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .cheat-item {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
            padding: 5px 8px;
            background: rgba(40, 40, 60, 0.3);
            border-radius: 4px;
        }

        .cheat-pattern {
            font-family: monospace;
            color: #ff79c6;
            min-width: 60px;
        }

        .cheat-desc {
            color: #888;
        }

        .stats-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .stat-badge {
            background: rgba(60, 60, 80, 0.5);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.85em;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #667eea;
            font-weight: 500;
            margin-left: 5px;
        }

        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Regex Visualizer</h1>
            <p class="subtitle">Parse, visualize, and test regular expressions</p>
        </header>

        <div class="main-content">
            <div class="left-panel">
                <div class="panel">
                    <div class="panel-title">Regular Expression</div>
                    <div class="input-group">
                        <div class="regex-input-container">
                            <span class="regex-delimiter">/</span>
                            <input type="text" id="regex-input" placeholder="Enter regex pattern..." value="(\w+)@(\w+)\.(\w+)">
                            <span class="regex-delimiter">/</span>
                            <div class="flags-container">
                                <button class="flag-btn active" data-flag="g">g</button>
                                <button class="flag-btn" data-flag="i">i</button>
                                <button class="flag-btn" data-flag="m">m</button>
                                <button class="flag-btn" data-flag="s">s</button>
                            </div>
                        </div>
                        <div class="error-message" id="error-message"></div>
                    </div>

                    <div class="stats-row" id="stats-row">
                        <div class="stat-badge">
                            <span class="stat-label">Matches:</span>
                            <span class="stat-value" id="match-count">0</span>
                        </div>
                        <div class="stat-badge">
                            <span class="stat-label">Groups:</span>
                            <span class="stat-value" id="group-count">0</span>
                        </div>
                        <div class="stat-badge">
                            <span class="stat-label">Pattern Length:</span>
                            <span class="stat-value" id="pattern-length">0</span>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Railroad Diagram</div>
                    <div class="diagram-container">
                        <canvas id="diagram-canvas"></canvas>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Test String</div>
                    <textarea id="test-input" placeholder="Enter text to test against the regex...">Contact us at support@example.com or sales@company.org for more info.</textarea>
                </div>

                <div class="panel">
                    <div class="panel-title">Highlighted Matches</div>
                    <div class="highlighted-text" id="highlighted-text"></div>
                </div>

                <div class="panel">
                    <div class="panel-title">Match Details</div>
                    <div class="matches-container" id="matches-container"></div>
                </div>
            </div>

            <div class="right-panel">
                <div class="panel">
                    <div class="panel-title">Examples</div>
                    <div class="examples-grid">
                        <button class="example-btn" data-pattern="(\w+)@(\w+)\.(\w+)" data-test="Email: user@domain.com">
                            <span class="example-pattern">(\w+)@(\w+)\.(\w+)</span>
                            <span class="example-desc">Email address</span>
                        </button>
                        <button class="example-btn" data-pattern="\b\d{3}[-.]?\d{3}[-.]?\d{4}\b" data-test="Call 555-123-4567 or 555.987.6543">
                            <span class="example-pattern">\b\d{3}[-.]?\d{3}[-.]?\d{4}\b</span>
                            <span class="example-desc">Phone number</span>
                        </button>
                        <button class="example-btn" data-pattern="https?://[\w.-]+(/[\w.-]*)*" data-test="Visit https://example.com/path or http://test.org">
                            <span class="example-pattern">https?://[\w.-]+(/[\w.-]*)*</span>
                            <span class="example-desc">URL pattern</span>
                        </button>
                        <button class="example-btn" data-pattern="\b[A-Z][a-z]+\b" data-test="Hello World from JavaScript">
                            <span class="example-pattern">\b[A-Z][a-z]+\b</span>
                            <span class="example-desc">Capitalized words</span>
                        </button>
                        <button class="example-btn" data-pattern="#([0-9A-Fa-f]{6}|[0-9A-Fa-f]{3})\b" data-test="Colors: #FF0000 #0f0 #123456">
                            <span class="example-pattern">#([0-9A-Fa-f]{6}|[0-9A-Fa-f]{3})</span>
                            <span class="example-desc">Hex color code</span>
                        </button>
                        <button class="example-btn" data-pattern="\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" data-test="IPs: 192.168.1.1 and 10.0.0.255">
                            <span class="example-pattern">\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b</span>
                            <span class="example-desc">IPv4 address</span>
                        </button>
                        <button class="example-btn" data-pattern="<(\w+)[^>]*>.*?</\1>" data-test="<div class='test'>content</div>">
                            <span class="example-pattern">&lt;(\w+)[^>]*>.*?&lt;/\1></span>
                            <span class="example-desc">HTML tag pair</span>
                        </button>
                        <button class="example-btn" data-pattern="\$[\d,]+(\.\d{2})?" data-test="Prices: $1,234.56 and $99">
                            <span class="example-pattern">\$[\d,]+(\.\d{2})?</span>
                            <span class="example-desc">Currency amount</span>
                        </button>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Quick Reference</div>
                    <div class="cheatsheet">
                        <div class="cheat-category">
                            <div class="cheat-title">Character Classes</div>
                            <div class="cheat-item"><span class="cheat-pattern">.</span><span class="cheat-desc">Any character</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">\d</span><span class="cheat-desc">Digit [0-9]</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">\w</span><span class="cheat-desc">Word char [a-zA-Z0-9_]</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">\s</span><span class="cheat-desc">Whitespace</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">[abc]</span><span class="cheat-desc">Character set</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">[^abc]</span><span class="cheat-desc">Negated set</span></div>
                        </div>
                        <div class="cheat-category">
                            <div class="cheat-title">Quantifiers</div>
                            <div class="cheat-item"><span class="cheat-pattern">*</span><span class="cheat-desc">0 or more</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">+</span><span class="cheat-desc">1 or more</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">?</span><span class="cheat-desc">0 or 1</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">{n}</span><span class="cheat-desc">Exactly n</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">{n,m}</span><span class="cheat-desc">Between n and m</span></div>
                        </div>
                        <div class="cheat-category">
                            <div class="cheat-title">Anchors</div>
                            <div class="cheat-item"><span class="cheat-pattern">^</span><span class="cheat-desc">Start of string</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">$</span><span class="cheat-desc">End of string</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">\b</span><span class="cheat-desc">Word boundary</span></div>
                        </div>
                        <div class="cheat-category">
                            <div class="cheat-title">Groups</div>
                            <div class="cheat-item"><span class="cheat-pattern">(abc)</span><span class="cheat-desc">Capturing group</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">(?:abc)</span><span class="cheat-desc">Non-capturing</span></div>
                            <div class="cheat-item"><span class="cheat-pattern">a|b</span><span class="cheat-desc">Alternation</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const regexInput = document.getElementById('regex-input');
        const testInput = document.getElementById('test-input');
        const errorMessage = document.getElementById('error-message');
        const highlightedText = document.getElementById('highlighted-text');
        const matchesContainer = document.getElementById('matches-container');
        const canvas = document.getElementById('diagram-canvas');
        const ctx = canvas.getContext('2d');

        let flags = 'g';

        // Parse regex into AST-like structure for visualization
        function parseRegex(pattern) {
            const tokens = [];
            let i = 0;

            while (i < pattern.length) {
                const char = pattern[i];

                if (char === '\\' && i + 1 < pattern.length) {
                    const next = pattern[i + 1];
                    const escapeMap = {
                        'd': 'digit',
                        'D': 'non-digit',
                        'w': 'word',
                        'W': 'non-word',
                        's': 'whitespace',
                        'S': 'non-whitespace',
                        'b': 'boundary',
                        'B': 'non-boundary',
                        'n': 'newline',
                        't': 'tab',
                        'r': 'return'
                    };

                    if (escapeMap[next]) {
                        tokens.push({ type: 'escape', value: '\\' + next, desc: escapeMap[next] });
                    } else if (/\d/.test(next)) {
                        tokens.push({ type: 'backref', value: '\\' + next, desc: 'backreference ' + next });
                    } else {
                        tokens.push({ type: 'literal', value: next, desc: 'literal' });
                    }
                    i += 2;
                } else if (char === '[') {
                    // Character class
                    let classEnd = i + 1;
                    if (pattern[classEnd] === '^') classEnd++;
                    if (pattern[classEnd] === ']') classEnd++;
                    while (classEnd < pattern.length && pattern[classEnd] !== ']') {
                        if (pattern[classEnd] === '\\') classEnd++;
                        classEnd++;
                    }
                    const classContent = pattern.slice(i, classEnd + 1);
                    tokens.push({ type: 'class', value: classContent, desc: 'character class' });
                    i = classEnd + 1;
                } else if (char === '(') {
                    // Group
                    let groupType = 'group';
                    let start = i + 1;

                    if (pattern[i + 1] === '?') {
                        if (pattern[i + 2] === ':') {
                            groupType = 'non-capturing';
                            start = i + 3;
                        } else if (pattern[i + 2] === '=') {
                            groupType = 'lookahead';
                            start = i + 3;
                        } else if (pattern[i + 2] === '!') {
                            groupType = 'neg-lookahead';
                            start = i + 3;
                        } else if (pattern[i + 2] === '<' && pattern[i + 3] === '=') {
                            groupType = 'lookbehind';
                            start = i + 4;
                        } else if (pattern[i + 2] === '<' && pattern[i + 3] === '!') {
                            groupType = 'neg-lookbehind';
                            start = i + 4;
                        }
                    }

                    // Find matching closing paren
                    let depth = 1;
                    let end = start;
                    while (end < pattern.length && depth > 0) {
                        if (pattern[end] === '\\') {
                            end++;
                        } else if (pattern[end] === '(') {
                            depth++;
                        } else if (pattern[end] === ')') {
                            depth--;
                        }
                        end++;
                    }

                    const content = pattern.slice(start, end - 1);
                    tokens.push({
                        type: groupType,
                        value: '(' + content + ')',
                        content: content,
                        children: parseRegex(content)
                    });
                    i = end;
                } else if (char === '|') {
                    tokens.push({ type: 'alternation', value: '|', desc: 'or' });
                    i++;
                } else if (char === '.') {
                    tokens.push({ type: 'dot', value: '.', desc: 'any character' });
                    i++;
                } else if (char === '^') {
                    tokens.push({ type: 'anchor', value: '^', desc: 'start' });
                    i++;
                } else if (char === '$') {
                    tokens.push({ type: 'anchor', value: '$', desc: 'end' });
                    i++;
                } else if (char === '*' || char === '+' || char === '?') {
                    const lazy = pattern[i + 1] === '?';
                    tokens.push({
                        type: 'quantifier',
                        value: char + (lazy ? '?' : ''),
                        desc: char === '*' ? '0+' : char === '+' ? '1+' : '0-1'
                    });
                    i += lazy ? 2 : 1;
                } else if (char === '{') {
                    let end = i + 1;
                    while (end < pattern.length && pattern[end] !== '}') end++;
                    const quant = pattern.slice(i, end + 1);
                    const lazy = pattern[end + 1] === '?';
                    tokens.push({ type: 'quantifier', value: quant + (lazy ? '?' : ''), desc: quant });
                    i = end + 1 + (lazy ? 1 : 0);
                } else {
                    tokens.push({ type: 'literal', value: char, desc: 'literal' });
                    i++;
                }
            }

            return tokens;
        }

        // Draw railroad diagram
        function drawDiagram(pattern) {
            const tokens = parseRegex(pattern);

            // Calculate dimensions
            const nodeHeight = 30;
            const nodeSpacing = 15;
            const padding = 40;
            let totalWidth = padding * 2;

            tokens.forEach(token => {
                totalWidth += getTokenWidth(token) + nodeSpacing;
            });

            totalWidth = Math.max(totalWidth, 300);
            const height = 120;

            canvas.width = totalWidth;
            canvas.height = height;

            ctx.fillStyle = 'rgba(15, 15, 25, 0.8)';
            ctx.fillRect(0, 0, totalWidth, height);

            const centerY = height / 2;
            let x = padding;

            // Start node
            ctx.beginPath();
            ctx.arc(x, centerY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#667eea';
            ctx.fill();
            x += 20;

            // Draw main line
            ctx.beginPath();
            ctx.moveTo(padding + 8, centerY);
            ctx.lineTo(totalWidth - padding - 8, centerY);
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw tokens
            tokens.forEach((token, index) => {
                x = drawToken(token, x, centerY, index);
                x += nodeSpacing;
            });

            // End node
            ctx.beginPath();
            ctx.arc(totalWidth - padding, centerY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#667eea';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(totalWidth - padding, centerY, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#0a0a15';
            ctx.fill();
        }

        function getTokenWidth(token) {
            ctx.font = '12px Courier New';
            const textWidth = ctx.measureText(token.value).width;
            return Math.max(textWidth + 20, 40);
        }

        function drawToken(token, x, y, index) {
            const width = getTokenWidth(token);
            const height = 28;

            // Background color based on type
            const colors = {
                literal: '#3d5a80',
                escape: '#ee6c4d',
                class: '#8338ec',
                group: '#06d6a0',
                'non-capturing': '#118ab2',
                dot: '#ffd166',
                anchor: '#ef476f',
                quantifier: '#073b4c',
                alternation: '#f72585'
            };

            const color = colors[token.type] || '#555';

            // Draw rounded rect
            ctx.beginPath();
            const radius = token.type === 'anchor' ? height / 2 : 6;
            ctx.roundRect(x, y - height / 2, width, height, radius);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(token.value, x + width / 2, y);

            // Draw description below
            if (token.desc) {
                ctx.fillStyle = '#888';
                ctx.font = '10px sans-serif';
                ctx.fillText(token.desc, x + width / 2, y + 25);
            }

            // Draw quantifier loop
            if (token.type === 'quantifier' && index > 0) {
                ctx.beginPath();
                ctx.arc(x - nodeSpacing / 2, y - 20, 10, 0, Math.PI, true);
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Arrow
                ctx.beginPath();
                ctx.moveTo(x - nodeSpacing / 2 - 10, y - 20);
                ctx.lineTo(x - nodeSpacing / 2 - 15, y - 25);
                ctx.lineTo(x - nodeSpacing / 2 - 15, y - 15);
                ctx.closePath();
                ctx.fillStyle = '#667eea';
                ctx.fill();
            }

            return x + width;
        }

        // Polyfill for roundRect if needed
        if (!ctx.roundRect) {
            ctx.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        // Update matches
        function updateMatches() {
            const pattern = regexInput.value;
            const testString = testInput.value;

            try {
                const regex = new RegExp(pattern, flags);
                errorMessage.classList.remove('visible');

                // Draw diagram
                drawDiagram(pattern);

                // Find matches
                const matches = [];
                let match;

                if (flags.includes('g')) {
                    while ((match = regex.exec(testString)) !== null) {
                        matches.push({
                            text: match[0],
                            index: match.index,
                            groups: match.slice(1)
                        });
                        if (match.index === regex.lastIndex) regex.lastIndex++;
                    }
                } else {
                    match = regex.exec(testString);
                    if (match) {
                        matches.push({
                            text: match[0],
                            index: match.index,
                            groups: match.slice(1)
                        });
                    }
                }

                // Update stats
                document.getElementById('match-count').textContent = matches.length;
                document.getElementById('group-count').textContent =
                    matches.length > 0 ? matches[0].groups.length : 0;
                document.getElementById('pattern-length').textContent = pattern.length;

                // Highlight matches in text
                let highlighted = '';
                let lastIndex = 0;

                matches.forEach((m, i) => {
                    highlighted += escapeHtml(testString.slice(lastIndex, m.index));
                    highlighted += `<span class="highlight">${escapeHtml(m.text)}</span>`;
                    lastIndex = m.index + m.text.length;
                });
                highlighted += escapeHtml(testString.slice(lastIndex));

                highlightedText.innerHTML = highlighted || '<span style="color: #666">No matches found</span>';

                // Display match details
                if (matches.length > 0) {
                    matchesContainer.innerHTML = matches.map((m, i) => `
                        <div class="match-item">
                            <div class="match-header">
                                <span class="match-index">Match ${i + 1}</span>
                                <span class="match-position">Index: ${m.index}</span>
                            </div>
                            <div class="match-text">${escapeHtml(m.text)}</div>
                            ${m.groups.length > 0 ? `
                                <div class="match-groups">
                                    ${m.groups.map((g, j) => `
                                        <div class="group-item">
                                            <span class="group-index">Group ${j + 1}:</span>
                                            <span class="group-value">${g !== undefined ? escapeHtml(g) : '(undefined)'}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                        </div>
                    `).join('');
                } else {
                    matchesContainer.innerHTML = '<div style="color: #666; padding: 20px; text-align: center;">No matches found</div>';
                }

            } catch (e) {
                errorMessage.textContent = e.message;
                errorMessage.classList.add('visible');

                // Clear displays
                ctx.fillStyle = 'rgba(15, 15, 25, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ff6b6b';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Invalid pattern', canvas.width / 2, canvas.height / 2);

                highlightedText.innerHTML = '<span style="color: #ff6b6b">Invalid regex pattern</span>';
                matchesContainer.innerHTML = '';
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Event listeners
        regexInput.addEventListener('input', updateMatches);
        testInput.addEventListener('input', updateMatches);

        document.querySelectorAll('.flag-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                btn.classList.toggle('active');
                flags = Array.from(document.querySelectorAll('.flag-btn.active'))
                    .map(b => b.dataset.flag)
                    .join('');
                updateMatches();
            });
        });

        document.querySelectorAll('.example-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                regexInput.value = btn.dataset.pattern;
                testInput.value = btn.dataset.test;
                updateMatches();
            });
        });

        // Initialize
        canvas.width = 600;
        canvas.height = 120;
        updateMatches();
    </script>
</body>
</html>
